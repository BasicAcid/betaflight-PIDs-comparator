<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Betaflight PID Tune Comparator</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="app-container">
        <!-- Sticky Header -->
        <header class="header">
            <div class="header-content">
                <div class="header-left">
                    <a href="#" class="logo">Betaflight PID Comparator</a>
                    <a href="https://github.com/BasicAcid/betaflight-PIDs-comparator" target="_blank" rel="noopener noreferrer" class="github-link">
                        <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M12 0C5.374 0 0 5.373 0 12 0 17.302 3.438 21.8 8.207 23.387c.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23A11.509 11.509 0 0112 5.803c1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z"/>
                        </svg>
                        GitHub
                    </a>
                </div>
                <div class="header-actions">
                    <button class="btn btn-primary" id="compareBtn" disabled>
                        Compare
                    </button>
                    <button class="btn btn-secondary" id="clearBtn">
                        Clear All
                    </button>
                </div>
            </div>
        </header>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-content">
                <div class="status-badges">
                    <span class="badge badge-info" id="presetsStatus">
                        <div class="loading-spinner"></div>
                        Loading presets...
                    </span>
                    <span class="badge" id="configAStatus">Config A: Empty</span>
                    <span class="badge" id="configBStatus">Config B: Empty</span>
                </div>
                <div id="quickStats" class="hidden">
                    Ready to compare • <span id="totalSettings">0</span> total settings
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Configuration Grid -->
            <div class="config-grid">
                <!-- Configuration A -->
                <div class="config-card">
                    <div class="config-header">
                        <h2 class="config-title">Configuration A</h2>
                        <span class="config-status status-empty" id="statusA">Empty</span>
                    </div>

                    <div class="input-tabs">
                        <button class="tab-btn active" onclick="switchTab('A', 'text')">CLI Text</button>
                        <button class="tab-btn" onclick="switchTab('A', 'preset')">Preset</button>
                    </div>

                    <!-- CLI Text Tab -->
                    <div class="tab-content active" id="tabA-text">
                        <div class="form-group">
                            <label class="form-label" for="cliInputA">Paste CLI Export</label>
                            <textarea
                                class="form-control textarea"
                                id="cliInputA"
                                placeholder="# Betaflight / STM32F405 4.4.0
set gyro_lpf1_static_hz = 250
set p_pitch = 58
set i_pitch = 52
..."></textarea>
                        </div>
                        <button class="btn btn-primary" onclick="loadConfigFromText('A')">
                            Load Config A
                        </button>
                    </div>

                    <!-- Preset Tab -->
                    <div class="tab-content" id="tabA-preset">
                        <div class="form-group">
                            <label class="form-label" for="presetSearchA">Search Presets</label>
                            <input type="text" class="form-control" id="presetSearchA" placeholder="Type to search presets...">
                        </div>

                        <div class="form-group">
                            <label class="form-label" for="presetSelectA">Choose Preset</label>
                            <select class="form-control preset-select" id="presetSelectA" size="6">
                                <option value="">Loading presets...</option>
                            </select>
                            <div class="preset-mobile-list hidden" id="presetMobileListA"></div>
                        </div>

                        <div class="preset-options hidden" id="presetOptionsA">
                            <div class="options-header">
                                <span>Preset Options</span>
                                <span class="badge badge-info" id="optionsSummaryA"></span>
                            </div>
                            <div id="optionsListA"></div>
                        </div>
                    </div>

                    <div class="form-group mt-4" id="configInfoA" style="display: none;">
                        <div style="font-size: 13px; color: #6b7280; padding: 8px 12px; background: #f9fafb; border-radius: 6px;">
                            <div id="configDetailsA"></div>
                        </div>
                    </div>
                </div>

                <!-- VS Section -->
                <div class="vs-section">
                    <div class="vs-label">VS</div>
                </div>

                <!-- Configuration B -->
                <div class="config-card">
                    <div class="config-header">
                        <h2 class="config-title">Configuration B</h2>
                        <span class="config-status status-empty" id="statusB">Empty</span>
                    </div>

                    <div class="input-tabs">
                        <button class="tab-btn active" onclick="switchTab('B', 'text')">CLI Text</button>
                        <button class="tab-btn" onclick="switchTab('B', 'preset')">Preset</button>
                    </div>

                    <!-- CLI Text Tab -->
                    <div class="tab-content active" id="tabB-text">
                        <div class="form-group">
                            <label class="form-label" for="cliInputB">Paste CLI Export</label>
                            <textarea
                                class="form-control textarea"
                                id="cliInputB"
                                placeholder="Paste second configuration here..."></textarea>
                        </div>
                        <button class="btn btn-primary" onclick="loadConfigFromText('B')">
                            Load Config B
                        </button>
                    </div>

                    <!-- Preset Tab -->
                    <div class="tab-content" id="tabB-preset">
                        <div class="form-group">
                            <label class="form-label" for="presetSearchB">Search Presets</label>
                            <input type="text" class="form-control" id="presetSearchB" placeholder="Type to search presets...">
                        </div>

                        <div class="form-group">
                            <label class="form-label" for="presetSelectB">Choose Preset</label>
                            <select class="form-control preset-select" id="presetSelectB" size="6">
                                <option value="">Loading presets...</option>
                            </select>
                            <div class="preset-mobile-list hidden" id="presetMobileListB"></div>
                        </div>

                        <div class="preset-options hidden" id="presetOptionsB">
                            <div class="options-header">
                                <span>Preset Options</span>
                                <span class="badge badge-info" id="optionsSummaryB"></span>
                            </div>
                            <div id="optionsListB"></div>
                        </div>
                    </div>

                    <div class="form-group mt-4" id="configInfoB" style="display: none;">
                        <div style="font-size: 13px; color: #6b7280; padding: 8px 12px; background: #f9fafb; border-radius: 6px;">
                            <div id="configDetailsB"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Results Section -->
            <div class="results-container hidden" id="resultsContainer">
                <div class="results-header">
                    <h2 class="results-title">Comparison Results</h2>
                    <div class="results-nav">
                        <button class="nav-btn active" onclick="showResultsTab('summary')">Summary</button>
                        <button class="nav-btn" onclick="showResultsTab('configs')">Individual</button>
                    </div>
                </div>

                <div class="results-content">
                    <!-- Summary Tab -->
                    <div class="tab-content active" id="results-summary">
                        <div class="comparison-summary">
                            <h3 style="margin: 0 0 8px 0; color: #374151;">Comparison Overview</h3>
                            <div id="comparisonMetadata" style="font-size: 14px; color: #6b7280; margin-bottom: 16px;"></div>
                            <div class="summary-grid">
                                <div class="summary-item">
                                    <span class="summary-number" id="differentCount">0</span>
                                    <span class="summary-label">Different</span>
                                </div>
                                <div class="summary-item">
                                    <span class="summary-number" id="onlyACount">0</span>
                                    <span class="summary-label">Only A</span>
                                </div>
                                <div class="summary-item">
                                    <span class="summary-number" id="onlyBCount">0</span>
                                    <span class="summary-label">Only B</span>
                                </div>
                                <div class="summary-item">
                                    <span class="summary-number" id="sameCount">0</span>
                                    <span class="summary-label">Identical</span>
                                </div>
                            </div>
                        </div>
                        <div id="comparisonDiff"></div>
                    </div>


                    <div class="tab-content" id="results-configs">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px;">
                            <div>
                                <h3 style="color: #374151; margin-bottom: 16px;">Configuration A</h3>
                                <div id="categorizedSettingsA"></div>
                            </div>
                            <div>
                                <h3 style="color: #374151; margin-bottom: 16px;">Configuration B</h3>
                                <div id="categorizedSettingsB"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Help Section -->
            <div style="background: rgba(255, 255, 255, 0.9); border-radius: 8px; padding: 16px; margin-top: 24px; font-size: 14px; color: #64748b; border: 1px solid #e2e8f0;">
                <strong style="color: #374151;">How to use:</strong> Load configurations via CLI text or preset selection, then compare to see differences.
                Presets with [number] have configurable options. Options marked with warning indicators use advanced templating and are not supported.
            </div>

            <!-- Support Section -->
            <div class="support-section">
                <button class="support-toggle" onclick="toggleSupport()" id="supportToggle">
                    <span>☕ Support this project</span>
                    <svg width="12" height="12" fill="currentColor" viewBox="0 0 16 16" class="support-arrow">
                        <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
                    </svg>
                </button>
                <div class="support-content hidden" id="supportContent">
                    <div class="support-text">
                        If this tool helped you, consider supporting its development:
                    </div>
                    <div class="crypto-addresses">
                        <div class="crypto-item">
                            <span class="crypto-label">Bitcoin (BTC):</span>
                            <code class="crypto-address" onclick="copyToClipboard(this)" title="Click to copy">bc1qem980z3k6ey25yjwcf9jeja28aluyjelc6zy92</code>
                        </div>
                        <div class="crypto-item">
                            <span class="crypto-label">Ethereum (ETH):</span>
                            <code class="crypto-address" onclick="copyToClipboard(this)" title="Click to copy">0x334F4f27e3920088378A8B51807fA93E570b6E81</code>
                        </div>
                    </div>
                    <div class="support-note">
                        Click addresses to copy • Thank you for your support! 🙏
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        function toggleSupport() {
            const content = document.getElementById('supportContent');
            const toggle = document.getElementById('supportToggle');
            const arrow = toggle.querySelector('.support-arrow');

            content.classList.toggle('hidden');
            arrow.style.transform = content.classList.contains('hidden') ? 'rotate(0deg)' : 'rotate(180deg)';
        }

        function copyToClipboard(element) {
            const text = element.textContent;
            navigator.clipboard.writeText(text).then(() => {
                const originalText = element.textContent;
                element.textContent = 'Copied!';
                element.style.background = '#dcfce7';
                element.style.color = '#15803d';

                setTimeout(() => {
                    element.textContent = originalText;
                    element.style.background = '';
                    element.style.color = '';
                }, 2000);
            }).catch(() => {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);

                const originalText = element.textContent;
                element.textContent = 'Copied!';
                setTimeout(() => {
                    element.textContent = originalText;
                }, 2000);
            });
        }
        class BetaflightCLIParser {
            constructor() {
                this.settings = new Map();
                this.categories = this.initializeCategories();
                this.presets = this.initializePresets();
            }

            initializePresets() {
                return {}; // Will be populated dynamically
            }

            async loadPresetsFromGitHub() {
                const startTime = Date.now();
                try {
                    const categories = ['tune']; // Only load TUNE presets
                    const versions = ['4.3', '4.4', '4.5'];
                    const loadedPresets = {};
                    let totalAttempted = 0;
                    let totalLoaded = 0;
                    let totalFiles = 0;
                    let processedFiles = 0;

                    // First pass: count total files to give accurate progress
                    updateProgress(0, 1, 'Scanning preset directories...', 'Counting available presets', startTime);

                    const filesByVersion = {};
                    for (const version of versions) {
                        for (const category of categories) {
                            try {
                                const dirUrl = `https://api.github.com/repos/betaflight/firmware-presets/contents/presets/${version}/${category}`;
                                const response = await fetch(dirUrl);

                                if (response.ok) {
                                    const files = await response.json();
                                    const txtFiles = files.filter(f => f.name.endsWith('.txt'));

                                    if (!filesByVersion[version]) filesByVersion[version] = [];
                                    filesByVersion[version] = filesByVersion[version].concat(txtFiles);
                                    totalFiles += txtFiles.length;

                                    console.log(`Found ${txtFiles.length} .txt files in ${version}/${category}`);
                                }
                            } catch (e) {
                                console.warn(`Failed to scan ${category} presets for ${version}:`, e);
                            }
                        }
                    }

                    updateProgress(1, 1, 'Found preset files', `${totalFiles} preset files discovered`, startTime);

                    // Second pass: actually load the files
                    for (const version of versions) {
                        if (!filesByVersion[version]) continue;

                        const versionFiles = filesByVersion[version];
                        updateProgress(processedFiles, totalFiles, `Loading Betaflight ${version} presets...`, `Processing ${versionFiles.length} files`, startTime);

                        for (let i = 0; i < versionFiles.length; i++) {
                            const file = versionFiles[i];

                            try {
                                // Skip utility files before fetching
                                const utilityFiles = ['blackbox_disable', 'reset_servo', 'defaults_tune_filters', 'defaults_', 'reset_all', 'reset_some', 'reset_'];
                                if (utilityFiles.some(util => file.name.toLowerCase().includes(util))) {
                                    processedFiles++;
                                    continue;
                                }

                                // Update progress with current file
                                updateProgress(
                                    processedFiles,
                                    totalFiles,
                                    `Loading ${version} presets...`,
                                    `Processing: ${file.name} (${processedFiles + 1}/${totalFiles})`,
                                    startTime
                                );

                                const presetResponse = await fetch(file.download_url);
                                if (!presetResponse.ok) {
                                    console.warn(`Failed to fetch ${file.name}: ${presetResponse.status}`);
                                    processedFiles++;
                                    continue;
                                }

                                const presetContent = await presetResponse.text();
                                const parsedPreset = this.parsePresetFile(presetContent, file.name, 'tune', version);

                                if (parsedPreset) {
                                    const key = `${version}_tune_${file.name.replace('.txt', '')}`;
                                    loadedPresets[key] = parsedPreset;
                                    totalLoaded++;
                                    console.log(`✓ Loaded: ${parsedPreset.title} (${file.name})`);
                                } else {
                                    console.warn(`Failed to parse ${file.name} - no relevant tune settings found`);
                                }

                                totalAttempted++;
                                processedFiles++;

                                // Small delay to prevent overwhelming the API and allow UI updates
                                if (processedFiles % 5 === 0) {
                                    await new Promise(resolve => setTimeout(resolve, 50));
                                }

                            } catch (e) {
                                console.warn(`Failed to load preset ${file.name}:`, e);
                                processedFiles++;
                            }
                        }
                    }

                    // Final progress update
                    updateProgress(totalFiles, totalFiles, 'Preset loading complete', `Successfully loaded ${totalLoaded} of ${totalAttempted} presets`, startTime);

                    console.log(`Successfully loaded ${totalLoaded} out of ${totalAttempted} attempted tune presets`);
                    this.presets = loadedPresets;

                    // Show completion for a moment before hiding
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    return totalLoaded;
                } catch (error) {
                    console.error('Failed to load presets from GitHub:', error);
                    updateProgress(0, 1, 'Loading failed', 'Using fallback presets instead', startTime);

                    // Fallback to basic presets
                    this.presets = this.getFallbackPresets();

                    await new Promise(resolve => setTimeout(resolve, 1000));
                    return Object.keys(this.presets).length;
                }
            }

            parsePresetFile(content, filename, category, version) {
                try {
                    const lines = content.split('\n');
                    const metadata = {};
                    const settings = {};
                    const options = [];

                    let inOptionBlock = false;
                    let currentOption = null;
                    let inIncludeBlock = false;

                    for (const line of lines) {
                        const trimmed = line.trim();

                        if (trimmed.startsWith('#$ TITLE:')) {
                            metadata.title = trimmed.substring(9).trim();
                        } else if (trimmed.startsWith('#$ DESCRIPTION:')) {
                            const desc = trimmed.substring(15).trim();
                            if (desc && !desc.includes('<') && desc.length < 300) {
                                metadata.description = (metadata.description || '') + desc + ' ';
                            }
                        } else if (trimmed.startsWith('#$ CATEGORY:')) {
                            metadata.category = trimmed.substring(12).trim();
                        } else if (trimmed.startsWith('#$ AUTHOR:')) {
                            metadata.author = trimmed.substring(10).trim();
                        } else if (trimmed.startsWith('#$ STATUS:')) {
                            metadata.status = trimmed.substring(10).trim();
                        }

                        if (trimmed.startsWith('#$ INCLUDE:')) {
                            inIncludeBlock = true;
                            continue;
                        }

                        if (trimmed.startsWith('#$ OPTION BEGIN')) {
                            inOptionBlock = true;
                            const optionMatch = trimmed.match(/^#\$\s*OPTION\s+BEGIN\s*(?:\((CHECKED|UNCHECKED)\))?\s*:\s*(.+)$/);
                            if (optionMatch) {
                                currentOption = {
                                    name: optionMatch[2].trim(),
                                    checked: optionMatch[1] === 'CHECKED',
                                    settings: {}
                                };
                            }
                            continue;
                        } else if (trimmed.startsWith('#$ OPTION END')) {
                            if (currentOption) {
                                options.push(currentOption);
                                currentOption = null;
                            }
                            inOptionBlock = false;
                            continue;
                        }

                        if (trimmed.startsWith('set ')) {
                            const setMatch = trimmed.match(/^set\s+([a-zA-Z0-9_]+)\s*=\s*(.+)$/);
                            if (setMatch) {
                                if (inOptionBlock && currentOption) {
                                    currentOption.settings[setMatch[1]] = setMatch[2].trim();
                                } else {
                                    settings[setMatch[1]] = setMatch[2].trim();
                                }
                            }
                        }
                    }

                    if (!metadata.title) {
                        metadata.title = filename.replace('.txt', '').replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    }

                    const hasRelevantSettings = Object.keys(settings).some(key =>
                        key.includes('_pitch') || key.includes('_roll') || key.includes('_yaw') ||
                        key.includes('dyn_notch') || key.includes('gyro_lpf') ||
                        key.includes('feedforward') || key.includes('dterm') ||
                        key.includes('vbat_sag') || key.includes('thrust_linear')
                    ) || options.length > 0;

                    if ((Object.keys(settings).length > 0 || options.length > 0) && (metadata.title || hasRelevantSettings)) {
                        return {
                            title: metadata.title,
                            description: (metadata.description || '').trim() || `PID tune for Betaflight ${version} (${filename})`,
                            category: metadata.category || 'TUNE',
                            author: metadata.author || 'Unknown',
                            status: metadata.status || 'COMMUNITY',
                            version: version,
                            filename: filename,
                            settings: settings,
                            options: options
                        };
                    }

                    return null;
                } catch (error) {
                    console.warn(`Failed to parse preset file ${filename}:`, error);
                    return null;
                }
            }

            getFallbackPresets() {
                return {
                    'basic_freestyle': {
                        title: 'Basic Freestyle Tune',
                        description: 'Conservative freestyle PID tune that works for most 5" quads',
                        category: 'TUNE',
                        author: 'Fallback',
                        version: '4.3',
                        settings: {
                            'p_pitch': '58', 'i_pitch': '52', 'd_pitch': '52', 'f_pitch': '145',
                            'p_roll': '55', 'i_roll': '50', 'd_roll': '48', 'f_roll': '138',
                            'p_yaw': '55', 'i_yaw': '50', 'd_yaw': '0', 'f_yaw': '138'
                        },
                        options: [
                            {
                                name: 'High Battery Voltage (4.35V)',
                                checked: false,
                                settings: {
                                    'vbat_max_cell_voltage': '435',
                                    'vbat_warning_cell_voltage': '350'
                                }
                            },
                            {
                                name: 'Race Mode Settings',
                                checked: false,
                                settings: {
                                    'p_pitch': '65',
                                    'i_pitch': '65',
                                    'd_pitch': '60'
                                }
                            }
                        ]
                    },
                    'basic_race': {
                        title: 'Basic Race Tune',
                        description: 'Aggressive racing PID tune with higher gains',
                        category: 'TUNE',
                        author: 'Fallback',
                        version: '4.3',
                        settings: {
                            'p_pitch': '70', 'i_pitch': '125', 'd_pitch': '65', 'f_pitch': '270',
                            'p_roll': '65', 'i_roll': '120', 'd_roll': '60', 'f_roll': '250',
                            'p_yaw': '65', 'i_yaw': '120', 'd_yaw': '0', 'f_yaw': '250'
                        },
                        options: []
                    }
                };
            }

            initializeCategories() {
                return {
                    'PID Controller': ['pid_process_denom', 'gyro_lpf1_static_hz', 'gyro_lpf1_dyn_min_hz', 'gyro_lpf1_dyn_max_hz', 'dyn_notch_count', 'dyn_notch_q', 'dyn_notch_min_hz', 'dyn_notch_max_hz'],
                    'PID Tuning': ['p_pitch', 'i_pitch', 'd_pitch', 'p_roll', 'i_roll', 'd_roll', 'p_yaw', 'i_yaw', 'd_yaw', 'f_pitch', 'f_roll', 'f_yaw'],
                    'RC Rates': ['rc_smoothing_type', 'rc_smoothing_input_hz', 'rc_smoothing_derivative_hz', 'serialrx_provider', 'sbus_inversion'],
                    'Rates': ['roll_rc_rate', 'pitch_rc_rate', 'yaw_rc_rate', 'roll_expo', 'pitch_expo', 'yaw_expo', 'roll_srate', 'pitch_srate', 'yaw_srate'],
                    'Motors': ['motor_pwm_protocol', 'motor_pwm_rate', 'motor_poles', 'thrust_linear'],
                    'Battery & Power': ['bat_capacity', 'vbat_max_cell_voltage', 'vbat_min_cell_voltage', 'vbat_warning_cell_voltage', 'ibata_scale', 'ibata_offset'],
                    'OSD': ['osd_vbat_pos', 'osd_rssi_pos', 'osd_tim_1_pos', 'osd_tim_2_pos', 'osd_remaining_time_estimate_pos', 'osd_flymode_pos'],
                    'Failsafe': ['failsafe_delay', 'failsafe_off_delay', 'failsafe_throttle', 'failsafe_switch_mode', 'failsafe_throttle_low_delay'],
                    'GPS': ['gps_provider', 'gps_sbas_mode', 'gps_auto_config', 'gps_auto_baud', 'gps_ublox_use_galileo'],
                    'Blackbox': ['blackbox_device', 'blackbox_record_acc', 'blackbox_mode'],
                    'System': ['gyro_hardware_lpf', 'gyro_32khz_hardware_lpf', 'gyro_sync_denom', 'scheduler_optimize_rate'],
                    'Other': []
                };
            }

            parse(cliText) {
                this.settings.clear();
                const lines = cliText.split('\n');
                let parsedCount = 0;

                for (const line of lines) {
                    const trimmed = line.trim();

                    if (!trimmed || trimmed.startsWith('#')) {
                        continue;
                    }

                    if (trimmed.startsWith('set ')) {
                        const result = this.parseSetCommand(trimmed);
                        if (result) {
                            this.settings.set(result.parameter, result.value);
                            parsedCount++;
                        }
                    }
                }

                return {
                    success: true,
                    settingsCount: parsedCount,
                    totalLines: lines.length,
                    settings: this.settings
                };
            }

            parseSetCommand(line) {
                const match = line.match(/^set\s+([a-zA-Z0-9_]+)\s*=\s*(.+)$/);
                if (match) {
                    return {
                        parameter: match[1].trim(),
                        value: match[2].trim()
                    };
                }
                return null;
            }

            categorizeSettings() {
                const categorized = {};
                const foundSettings = new Set();

                for (const [categoryName, parameters] of Object.entries(this.categories)) {
                    categorized[categoryName] = [];
                }

                for (const [categoryName, parameters] of Object.entries(this.categories)) {
                    if (categoryName === 'Other') continue;

                    for (const param of parameters) {
                        if (this.settings.has(param)) {
                            categorized[categoryName].push({
                                parameter: param,
                                value: this.settings.get(param)
                            });
                            foundSettings.add(param);
                        }
                    }
                }

                for (const [param, value] of this.settings) {
                    if (!foundSettings.has(param)) {
                        categorized['Other'].push({
                            parameter: param,
                            value: value
                        });
                    }
                }

                for (const categoryName of Object.keys(categorized)) {
                    if (categorized[categoryName].length === 0) {
                        delete categorized[categoryName];
                    }
                }

                return categorized;
            }
        }

        const parser = new BetaflightCLIParser();
        let presetsLoaded = false;
        let configA = null;
        let configB = null;
        let currentResultsTab = 'summary';
        let allPresetsA = []; // Store all preset options for filtering
        let allPresetsB = []; // Store all preset options for filtering
        let isMobileView = false;

        // Initialize app
        window.addEventListener('DOMContentLoaded', function() {
            checkMobileView();
            loadPresets();
            updateUI();
            setupSearchListeners();
            window.addEventListener('resize', checkMobileView);
        });

        function checkMobileView() {
            const wasMobile = isMobileView;
            isMobileView = window.innerWidth <= 768;

            if (wasMobile !== isMobileView) {
                updatePresetDisplay();
            }
        }

        function updatePresetDisplay() {
            const selectA = document.getElementById('presetSelectA');
            const selectB = document.getElementById('presetSelectB');
            const mobileListA = document.getElementById('presetMobileListA');
            const mobileListB = document.getElementById('presetMobileListB');

            if (isMobileView) {
                selectA.style.display = 'none';
                selectB.style.display = 'none';
                mobileListA.classList.remove('hidden');
                mobileListB.classList.remove('hidden');
            } else {
                selectA.style.display = 'block';
                selectB.style.display = 'block';
                mobileListA.classList.add('hidden');
                mobileListB.classList.add('hidden');
            }
        }

        function setupSearchListeners() {
            const searchA = document.getElementById('presetSearchA');
            const searchB = document.getElementById('presetSearchB');

            searchA.addEventListener('input', function() {
                filterPresets('A', this.value);
            });

            searchB.addEventListener('input', function() {
                filterPresets('B', this.value);
            });
        }

        function filterPresets(side, searchTerm) {
            const select = document.getElementById(`presetSelect${side}`);
            const mobileList = document.getElementById(`presetMobileList${side}`);
            const allPresets = side === 'A' ? allPresetsA : allPresetsB;

            // Clear current options
            select.innerHTML = '<option value="">Select a preset...</option>';
            mobileList.innerHTML = '';

            if (!searchTerm.trim()) {
                // No search term, show all presets
                populateSelectWithPresets(select, allPresets);
                populateMobileListWithPresets(mobileList, allPresets, side);
                return;
            }

            // Filter presets based on search term
            const searchLower = searchTerm.toLowerCase();
            const filtered = allPresets.filter(preset => {
                const title = preset.preset.title.toLowerCase();
                const author = (preset.preset.author || '').toLowerCase();
                const description = (preset.preset.description || '').toLowerCase();

                return title.includes(searchLower) ||
                       author.includes(searchLower) ||
                       description.includes(searchLower);
            });

            populateSelectWithPresets(select, filtered);
            populateMobileListWithPresets(mobileList, filtered, side);
        }

        function populateSelectWithPresets(select, presets) {
            const grouped = {};

            // Group presets by version
            for (const preset of presets) {
                const groupKey = `Betaflight ${preset.preset.version}`;
                if (!grouped[groupKey]) {
                    grouped[groupKey] = [];
                }
                grouped[groupKey].push(preset);
            }

            // Sort within each group
            for (const groupKey in grouped) {
                grouped[groupKey].sort((a, b) => a.preset.title.localeCompare(b.preset.title));
            }

            // Add options to select
            for (const [groupName, presets] of Object.entries(grouped)) {
                if (presets.length > 0) {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = groupName;

                    for (const {key, preset} of presets) {
                        const option = document.createElement('option');
                        option.value = key;
                        const optionsIndicator = preset.options && preset.options.length > 0 ? ` [${preset.options.length}]` : '';
                        option.textContent = `${preset.title}${preset.author ? ` (${preset.author})` : ''}${optionsIndicator}`;
                        optgroup.appendChild(option);
                    }

                    select.appendChild(optgroup);
                }
            }
        }

        function populateMobileListWithPresets(mobileList, presets, side) {
            const grouped = {};

            // Group presets by version
            for (const preset of presets) {
                const groupKey = `Betaflight ${preset.preset.version}`;
                if (!grouped[groupKey]) {
                    grouped[groupKey] = [];
                }
                grouped[groupKey].push(preset);
            }

            // Sort within each group
            for (const groupKey in grouped) {
                grouped[groupKey].sort((a, b) => a.preset.title.localeCompare(b.preset.title));
            }

            // Build mobile list HTML
            let html = '';
            if (Object.keys(grouped).length === 0) {
                html = '<div class="preset-mobile-item empty">No presets found</div>';
            } else {
                for (const [groupName, presets] of Object.entries(grouped)) {
                    if (presets.length > 0) {
                        html += `<div class="preset-mobile-group">${groupName}</div>`;

                        for (const {key, preset} of presets) {
                            const optionsIndicator = preset.options && preset.options.length > 0 ? ` [${preset.options.length}]` : '';
                            html += `
                                <div class="preset-mobile-item" data-preset-key="${key}" onclick="selectMobilePreset('${side}', '${key}')">
                                    <div class="preset-mobile-title">${preset.title}${optionsIndicator}</div>
                                    ${preset.author ? `<div class="preset-mobile-author">${preset.author}</div>` : ''}
                                </div>
                            `;
                        }
                    }
                }
            }

            mobileList.innerHTML = html;
        }

        function selectMobilePreset(side, presetKey) {
            // Update the hidden select element to maintain compatibility
            const select = document.getElementById(`presetSelect${side}`);
            select.value = presetKey;

            // Highlight selected item
            const mobileList = document.getElementById(`presetMobileList${side}`);
            const items = mobileList.querySelectorAll('.preset-mobile-item[data-preset-key]');
            items.forEach(item => item.classList.remove('selected'));

            const selectedItem = mobileList.querySelector(`[data-preset-key="${presetKey}"]`);
            if (selectedItem) {
                selectedItem.classList.add('selected');
            }

            // Trigger the same logic as select change
            if (presetKey) {
                showPresetOptions(side, presetKey);
            } else {
                hidePresetOptions(side);
                if (side === 'A') {
                    configA = null;
                } else {
                    configB = null;
                }
                updateUI();
            }
        }

        async function loadPresets() {
            const presetsStatus = document.getElementById('presetsStatus');

            try {
                // Create progress display
                showLoadingProgress();

                const count = await parser.loadPresetsFromGitHub();
                populatePresetDropdowns();

                hideLoadingProgress();
                presetsStatus.className = 'badge badge-success';
                presetsStatus.innerHTML = `${count} presets loaded`;

                presetsLoaded = true;
            } catch (error) {
                console.error('Failed to load presets:', error);
                hideLoadingProgress();
                presetsStatus.className = 'badge badge-warning';
                presetsStatus.innerHTML = 'Using fallback presets';
                populatePresetDropdowns();
            }
        }

        function showLoadingProgress() {
            const presetsStatus = document.getElementById('presetsStatus');
            presetsStatus.innerHTML = '<div class="loading-spinner"></div> Loading presets...';

            // Add progress container to main content
            const progressHtml = `
                <div class="progress-container" id="progressContainer">
                    <div class="progress-header">
                        <div class="progress-title">
                            <div class="loading-spinner"></div>
                            <span id="progressTitle">Initializing preset loader...</span>
                        </div>
                        <div class="progress-stats" id="progressStats">0%</div>
                    </div>
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="progressBar" style="width: 0%"></div>
                    </div>
                    <div class="progress-details">
                        <span id="progressDetails">Starting up...</span>
                        <span class="progress-eta" id="progressETA"></span>
                    </div>
                </div>
            `;

            // Insert progress after header but before main content
            const mainContent = document.querySelector('.main-content');
            mainContent.insertAdjacentHTML('afterbegin', progressHtml);
        }

        function updateProgress(current, total, title, details, startTime = null) {
            const progressBar = document.getElementById('progressBar');
            const progressStats = document.getElementById('progressStats');
            const progressTitle = document.getElementById('progressTitle');
            const progressDetails = document.getElementById('progressDetails');
            const progressETA = document.getElementById('progressETA');

            if (!progressBar) return; // Progress container not found

            const percentage = total > 0 ? Math.round((current / total) * 100) : 0;

            progressBar.style.width = `${percentage}%`;
            progressStats.textContent = `${percentage}%`;
            progressTitle.textContent = title;
            progressDetails.textContent = details;

            // Calculate ETA if we have a start time
            if (startTime && current > 0 && current < total) {
                const elapsed = Date.now() - startTime;
                const rate = current / elapsed; // items per ms
                const remaining = total - current;
                const etaMs = remaining / rate;

                if (etaMs > 0 && etaMs < 300000) { // Only show if less than 5 minutes
                    const etaSeconds = Math.round(etaMs / 1000);
                    if (etaSeconds < 60) {
                        progressETA.textContent = `~${etaSeconds}s remaining`;
                    } else {
                        const etaMinutes = Math.round(etaSeconds / 60);
                        progressETA.textContent = `~${etaMinutes}m remaining`;
                    }
                } else {
                    progressETA.textContent = '';
                }
            } else {
                progressETA.textContent = '';
            }
        }

        function hideLoadingProgress() {
            const progressContainer = document.getElementById('progressContainer');
            if (progressContainer) {
                progressContainer.remove();
            }
        }

        function populatePresetDropdowns() {
            const selectA = document.getElementById('presetSelectA');
            const selectB = document.getElementById('presetSelectB');
            const mobileListA = document.getElementById('presetMobileListA');
            const mobileListB = document.getElementById('presetMobileListB');

            // Prepare all presets data for filtering
            allPresetsA = [];
            allPresetsB = [];

            for (const [key, preset] of Object.entries(parser.presets)) {
                allPresetsA.push({key, preset});
                allPresetsB.push({key, preset});
            }

            // Populate both dropdowns and mobile lists initially with all presets
            populateSelectWithPresets(selectA, allPresetsA);
            populateSelectWithPresets(selectB, allPresetsB);
            populateMobileListWithPresets(mobileListA, allPresetsA, 'A');
            populateMobileListWithPresets(mobileListB, allPresetsB, 'B');

            // Update display based on screen size
            updatePresetDisplay();

            // Event listeners for select elements
            selectA.addEventListener('change', function() {
                if (this.value) {
                    showPresetOptions('A', this.value);
                } else {
                    hidePresetOptions('A');
                    configA = null;
                    updateUI();
                }
            });

            selectB.addEventListener('change', function() {
                if (this.value) {
                    showPresetOptions('B', this.value);
                } else {
                    hidePresetOptions('B');
                    configB = null;
                    updateUI();
                }
            });
        }

        function showPresetOptions(side, presetKey) {
            const preset = parser.presets[presetKey];
            const optionsDiv = document.getElementById(`presetOptions${side}`);
            const optionsListDiv = document.getElementById(`optionsList${side}`);
            const summaryBadge = document.getElementById(`optionsSummary${side}`);

            if (!preset || !preset.options || preset.options.length === 0) {
                hidePresetOptions(side);
                return;
            }

            let html = '';
            let supportedCount = 0;
            let unsupportedCount = 0;

            preset.options.forEach((option, index) => {
                const optionId = `option_${side}_${index}`;
                const hasSettings = option.settings && Object.keys(option.settings).length > 0;

                if (hasSettings) {
                    supportedCount++;
                    const settingsPreview = Object.entries(option.settings).slice(0, 2).map(([key, value]) =>
                        `${key} = ${value}`
                    ).join(', ');
                    const moreSettings = Object.keys(option.settings).length > 2 ? ` (+${Object.keys(option.settings).length - 2} more)` : '';

                    html += `
                        <div class="option-item">
                            <div class="option-label-wrapper">
                                <input type="checkbox" class="option-checkbox" id="${optionId}" ${option.checked ? 'checked' : ''}
                                       onchange="onOptionChanged('${side}')">
                                <label class="option-label" for="${optionId}">${option.name}</label>
                            </div>
                            <div class="option-settings">${settingsPreview}${moreSettings}</div>
                        </div>
                    `;
                } else {
                    unsupportedCount++;
                    html += `
                        <div class="option-item disabled">
                            <div class="option-label-wrapper">
                                <input type="checkbox" class="option-checkbox" id="${optionId}" disabled
                                       title="Uses advanced preset features not supported by this comparator">
                                <label class="option-label disabled" for="${optionId}">${option.name}</label>
                            </div>
                            <div class="option-unsupported">Uses advanced templating (includes, variables, etc.)</div>
                        </div>
                    `;
                }
            });

            optionsListDiv.innerHTML = html;
            summaryBadge.textContent = `${supportedCount} supported, ${unsupportedCount} unsupported`;
            optionsDiv.classList.remove('hidden');

            loadConfigFromPreset(side);
        }

        function hidePresetOptions(side) {
            const optionsDiv = document.getElementById(`presetOptions${side}`);
            optionsDiv.classList.add('hidden');
        }

        function onOptionChanged(side) {
            loadConfigFromPreset(side);
        }

        function switchTab(side, tab) {
            // Update tab buttons with immediate feedback
            const activeCard = document.querySelector(`#tab${side}-${tab}`).closest('.config-card');
            const buttons = activeCard.querySelectorAll('.tab-btn');

            buttons.forEach((btn, index) => {
                btn.classList.toggle('active', index === (tab === 'text' ? 0 : 1));
            });

            // Smooth tab content transition
            const textTab = document.getElementById(`tab${side}-text`);
            const presetTab = document.getElementById(`tab${side}-preset`);

            textTab.classList.toggle('active', tab === 'text');
            presetTab.classList.toggle('active', tab === 'preset');
        }

        function loadConfigFromText(side) {
            const textArea = document.getElementById(`cliInput${side}`);

            if (!textArea.value.trim()) {
                alert(`Please paste CLI export data for Configuration ${side}!`);
                return;
            }

            setLoadingState(side, true);

            // Small delay to show loading state
            setTimeout(() => {
                try {
                    const tempParser = new BetaflightCLIParser();
                    const result = tempParser.parse(textArea.value);

                    const config = {
                        type: 'text',
                        title: `Custom CLI Export ${side}`,
                        description: 'Loaded from CLI text',
                        settings: new Map(tempParser.settings),
                        metadata: {
                            settingsCount: result.settingsCount,
                            totalLines: result.totalLines
                        }
                    };

                    if (side === 'A') {
                        configA = config;
                    } else {
                        configB = config;
                    }

                    setLoadingState(side, false);
                    updateUI();

                } catch (error) {
                    console.error('Error parsing CLI:', error);
                    setLoadingState(side, false);
                    alert(`Error parsing CLI: ${error.message}`);
                }
            }, 200);
        }

        function loadConfigFromPreset(side) {
            const presetSelect = document.getElementById(`presetSelect${side}`);
            const selectedPreset = presetSelect.value;

            if (!selectedPreset) {
                if (side === 'A') {
                    configA = null;
                } else {
                    configB = null;
                }
                updateUI();
                return;
            }

            setLoadingState(side, true);

            // Small delay to show loading state
            setTimeout(() => {
                const preset = parser.presets[selectedPreset];
                if (!preset) {
                    console.error('Preset not found:', selectedPreset);
                    setLoadingState(side, false);
                    return;
                }

                const finalSettings = new Map(Object.entries(preset.settings));
                const appliedOptions = [];

                if (preset.options && preset.options.length > 0) {
                    preset.options.forEach((option, index) => {
                        const optionCheckbox = document.getElementById(`option_${side}_${index}`);
                        const isChecked = optionCheckbox && optionCheckbox.checked;
                        const isDisabled = optionCheckbox && optionCheckbox.disabled;
                        const hasSettings = option.settings && Object.keys(option.settings).length > 0;

                        if (isChecked && !isDisabled && hasSettings) {
                            for (const [key, value] of Object.entries(option.settings)) {
                                finalSettings.set(key, value);
                            }
                            appliedOptions.push(option.name);
                        }
                    });
                }

                const config = {
                    type: 'preset',
                    title: preset.title,
                    description: preset.description,
                    settings: finalSettings,
                    metadata: {
                        author: preset.author,
                        category: preset.category,
                        version: preset.version,
                        filename: preset.filename,
                        optionsApplied: appliedOptions
                    }
                };

                if (side === 'A') {
                    configA = config;
                } else {
                    configB = config;
                }

                setLoadingState(side, false);
                updateUI();
            }, 150);
        }

        function updateUI() {
            // Update status badges and card states
            const statusA = document.getElementById('statusA');
            const statusB = document.getElementById('statusB');
            const configAStatus = document.getElementById('configAStatus');
            const configBStatus = document.getElementById('configBStatus');
            const cardA = document.querySelector('.config-card:first-of-type');
            const cardB = document.querySelector('.config-card:last-of-type');

            if (configA) {
                statusA.textContent = 'Loaded';
                statusA.className = 'config-status status-loaded';
                configAStatus.textContent = `Config A: ${configA.title}`;
                configAStatus.className = 'badge badge-success';
                cardA.setAttribute('data-loaded', 'true');
                cardA.removeAttribute('data-loading');

                // Show config details with animation
                const detailsA = document.getElementById('configDetailsA');
                const infoA = document.getElementById('configInfoA');
                detailsA.innerHTML = `
                    <strong>${configA.title}</strong><br>
                    ${configA.settings.size} settings loaded
                    ${configA.metadata?.optionsApplied?.length ? `<br>Options: ${configA.metadata.optionsApplied.join(', ')}` : ''}
                `;
                infoA.style.display = 'block';
            } else {
                statusA.textContent = 'Empty';
                statusA.className = 'config-status status-empty';
                configAStatus.textContent = 'Config A: Empty';
                configAStatus.className = 'badge';
                cardA.removeAttribute('data-loaded');
                cardA.removeAttribute('data-loading');
                document.getElementById('configInfoA').style.display = 'none';
            }

            if (configB) {
                statusB.textContent = 'Loaded';
                statusB.className = 'config-status status-loaded';
                configBStatus.textContent = `Config B: ${configB.title}`;
                configBStatus.className = 'badge badge-success';
                cardB.setAttribute('data-loaded', 'true');
                cardB.removeAttribute('data-loading');

                // Show config details with animation
                const detailsB = document.getElementById('configDetailsB');
                const infoB = document.getElementById('configInfoB');
                detailsB.innerHTML = `
                    <strong>${configB.title}</strong><br>
                    ${configB.settings.size} settings loaded
                    ${configB.metadata?.optionsApplied?.length ? `<br>Options: ${configB.metadata.optionsApplied.join(', ')}` : ''}
                `;
                infoB.style.display = 'block';
            } else {
                statusB.textContent = 'Empty';
                statusB.className = 'config-status status-empty';
                configBStatus.textContent = 'Config B: Empty';
                configBStatus.className = 'badge';
                cardB.removeAttribute('data-loaded');
                cardB.removeAttribute('data-loading');
                document.getElementById('configInfoB').style.display = 'none';
            }

            // Update compare buttons with smooth state transition
            const canCompare = configA && configB;
            const compareBtn = document.getElementById('compareBtn');

            compareBtn.disabled = !canCompare;

            // Update quick stats
            const quickStats = document.getElementById('quickStats');
            const totalSettings = document.getElementById('totalSettings');

            if (canCompare) {
                const total = new Set([...configA.settings.keys(), ...configB.settings.keys()]).size;
                totalSettings.textContent = total;
                quickStats.classList.remove('hidden');
            } else {
                quickStats.classList.add('hidden');
            }
        }

        function setLoadingState(side, isLoading) {
            const card = side === 'A' ?
                document.querySelector('.config-card:first-of-type') :
                document.querySelector('.config-card:last-of-type');
            const status = document.getElementById(`status${side}`);
            const badge = document.getElementById(`config${side}Status`);

            if (isLoading) {
                card.setAttribute('data-loading', 'true');
                card.removeAttribute('data-loaded');
                status.textContent = 'Loading...';
                status.className = 'config-status status-loading';
                badge.textContent = `Config ${side}: Loading...`;
                badge.className = 'badge badge-info';
                badge.setAttribute('data-loading', 'true');
            } else {
                card.removeAttribute('data-loading');
                badge.removeAttribute('data-loading');
            }
        }

        function compareConfigs() {
            if (!configA || !configB) {
                alert('Please load both configurations first!');
                return;
            }

            const comparison = compareConfigurations(configA, configB);
            displayComparison(comparison);

            // Show results
            document.getElementById('resultsContainer').classList.remove('hidden');

            // Scroll to results
            document.getElementById('resultsContainer').scrollIntoView({
                behavior: 'smooth',
                block: 'start'
            });
        }

        function compareConfigurations(configA, configB) {
            const changes = [];
            const settingsA = configA.settings;
            const settingsB = configB.settings;

            const allParams = new Set([...settingsA.keys(), ...settingsB.keys()]);

            for (const param of allParams) {
                const valueA = settingsA.get(param);
                const valueB = settingsB.get(param);

                if (valueA === undefined && valueB !== undefined) {
                    changes.push({
                        parameter: param,
                        type: 'only_b',
                        valueA: null,
                        valueB: valueB
                    });
                } else if (valueA !== undefined && valueB === undefined) {
                    changes.push({
                        parameter: param,
                        type: 'only_a',
                        valueA: valueA,
                        valueB: null
                    });
                } else if (valueA !== valueB) {
                    changes.push({
                        parameter: param,
                        type: 'different',
                        valueA: valueA,
                        valueB: valueB
                    });
                } else {
                    changes.push({
                        parameter: param,
                        type: 'same',
                        valueA: valueA,
                        valueB: valueB
                    });
                }
            }

            return {
                configA: configA,
                configB: configB,
                changes: changes
            };
        }

        function displayComparison(comparison) {
            const different = comparison.changes.filter(c => c.type === 'different');
            const onlyA = comparison.changes.filter(c => c.type === 'only_a');
            const onlyB = comparison.changes.filter(c => c.type === 'only_b');
            const same = comparison.changes.filter(c => c.type === 'same');

            // Update summary numbers
            document.getElementById('differentCount').textContent = different.length;
            document.getElementById('onlyACount').textContent = onlyA.length;
            document.getElementById('onlyBCount').textContent = onlyB.length;
            document.getElementById('sameCount').textContent = same.length;

            // Update metadata
            const metadata = document.getElementById('comparisonMetadata');
            metadata.innerHTML = `
                <strong>A:</strong> ${comparison.configA.title} •
                <strong>B:</strong> ${comparison.configB.title}
            `;

            // Display differences
            let diffHtml = '';

            if (different.length > 0) {
                different.sort((a, b) => {
                    const pidParams = ['p_pitch', 'i_pitch', 'd_pitch', 'p_roll', 'i_roll', 'd_roll', 'p_yaw', 'i_yaw', 'd_yaw', 'f_pitch', 'f_roll', 'f_yaw'];
                    const aIsPid = pidParams.includes(a.parameter);
                    const bIsPid = pidParams.includes(b.parameter);
                    if (aIsPid && !bIsPid) return -1;
                    if (!aIsPid && bIsPid) return 1;
                    return a.parameter.localeCompare(b.parameter);
                });

                diffHtml += '<div class="diff-section"><div class="diff-header">Different Values</div>';
                for (const change of different) {
                    diffHtml += `
                        <div class="diff-item diff-changed">
                            <span class="setting-name">${change.parameter}</span>
                            <div class="setting-values">
                                <span class="value-a">A: ${change.valueA}</span>
                                →
                                <span class="value-b">B: ${change.valueB}</span>
                            </div>
                        </div>
                    `;
                }
                diffHtml += '</div>';
            }

            if (onlyA.length > 0) {
                diffHtml += '<div class="diff-section"><div class="diff-header">Only in Configuration A</div>';
                for (const change of onlyA) {
                    diffHtml += `
                        <div class="diff-item diff-only-a">
                            <span class="setting-name">${change.parameter}</span>
                            <span class="value-a">${change.valueA}</span>
                        </div>
                    `;
                }
                diffHtml += '</div>';
            }

            if (onlyB.length > 0) {
                diffHtml += '<div class="diff-section"><div class="diff-header">Only in Configuration B</div>';
                for (const change of onlyB) {
                    diffHtml += `
                        <div class="diff-item diff-only-b">
                            <span class="setting-name">${change.parameter}</span>
                            <span class="value-b">${change.valueB}</span>
                        </div>
                    `;
                }
                diffHtml += '</div>';
            }

            if (same.length > 0 && same.length <= 10) {
                diffHtml += '<div class="diff-section"><div class="diff-header">Identical Values</div>';
                for (const change of same) {
                    diffHtml += `
                        <div class="diff-item diff-same">
                            <span class="setting-name">${change.parameter}</span>
                            <span>${change.valueA}</span>
                        </div>
                    `;
                }
                diffHtml += '</div>';
            } else if (same.length > 10) {
                diffHtml += `<div class="diff-section"><div class="diff-header">${same.length} Identical Values</div></div>`;
            }

            if (different.length === 0 && onlyA.length === 0 && onlyB.length === 0) {
                diffHtml = '<div class="text-center" style="padding: 40px; color: #16a34a; font-weight: 500;">Configurations are identical!</div>';
            }

            document.getElementById('comparisonDiff').innerHTML = diffHtml;

            // Generate individual configs
            generateIndividualConfigs(comparison);
        }

        function generateIndividualConfigs(comparison) {
            const categorizedA = categorizeSettings(comparison.configA.settings);
            const categorizedB = categorizeSettings(comparison.configB.settings);

            document.getElementById('categorizedSettingsA').innerHTML = renderCategorizedSettings(categorizedA);
            document.getElementById('categorizedSettingsB').innerHTML = renderCategorizedSettings(categorizedB);
        }

        function categorizeSettings(settings) {
            const categories = parser.categories;
            const categorized = {};
            const foundSettings = new Set();

            for (const [categoryName, parameters] of Object.entries(categories)) {
                categorized[categoryName] = [];
            }

            for (const [categoryName, parameters] of Object.entries(categories)) {
                if (categoryName === 'Other') continue;

                for (const param of parameters) {
                    if (settings.has(param)) {
                        categorized[categoryName].push({
                            parameter: param,
                            value: settings.get(param)
                        });
                        foundSettings.add(param);
                    }
                }
            }

            for (const [param, value] of settings) {
                if (!foundSettings.has(param)) {
                    categorized['Other'].push({
                        parameter: param,
                        value: value
                    });
                }
            }

            for (const categoryName of Object.keys(categorized)) {
                if (categorized[categoryName].length === 0) {
                    delete categorized[categoryName];
                }
            }

            return categorized;
        }

        function renderCategorizedSettings(categorized) {
            let html = '';

            for (const [categoryName, settings] of Object.entries(categorized)) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #374151; font-size: 14px; font-weight: 600; margin-bottom: 8px; padding-bottom: 4px; border-bottom: 1px solid #e5e7eb;">
                            ${categoryName} (${settings.length})
                        </h4>
                        <div style="font-size: 12px; font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;">
                `;

                for (const setting of settings) {
                    html += `
                        <div style="display: flex; justify-content: space-between; padding: 2px 0; color: #6b7280;">
                            <span style="color: #374151; font-weight: 500;">${setting.parameter}</span>
                            <span>${setting.value}</span>
                        </div>
                    `;
                }

                html += '</div></div>';
            }

            return html;
        }

        function showResultsTab(tab) {
            currentResultsTab = tab;

            // Update nav buttons
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update content
            document.querySelectorAll('#resultsContainer .tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`results-${tab}`).classList.add('active');
        }

        function clearAll() {
            configA = null;
            configB = null;

            // Clear inputs
            document.getElementById('cliInputA').value = '';
            document.getElementById('cliInputB').value = '';
            document.getElementById('presetSelectA').value = '';
            document.getElementById('presetSelectB').value = '';
            document.getElementById('presetSearchA').value = '';
            document.getElementById('presetSearchB').value = '';

            // Clear mobile list selections
            const mobileListA = document.getElementById('presetMobileListA');
            const mobileListB = document.getElementById('presetMobileListB');
            if (mobileListA) {
                mobileListA.querySelectorAll('.preset-mobile-item').forEach(item => {
                    item.classList.remove('selected');
                });
            }
            if (mobileListB) {
                mobileListB.querySelectorAll('.preset-mobile-item').forEach(item => {
                    item.classList.remove('selected');
                });
            }

            // Reset preset dropdowns to show all presets
            filterPresets('A', '');
            filterPresets('B', '');

            // Hide options
            hidePresetOptions('A');
            hidePresetOptions('B');

            // Hide results
            document.getElementById('resultsContainer').classList.add('hidden');

            updateUI();
        }

        // Sync header buttons with main buttons
        document.getElementById('compareBtn').addEventListener('click', compareConfigs);
        document.getElementById('clearBtn').addEventListener('click', clearAll);
    </script>
</body>
</html>
