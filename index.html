<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Betaflight PID Tune Comparator</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .input-section {
            margin-bottom: 30px;
        }

        .cli-input {
            width: 100%;
            height: 200px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border: 2px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            resize: vertical;
        }

        .parse-button {
            background: #007acc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
        }

        .parse-button:hover {
            background: #005a9e;
        }

        .results-section {
            margin-top: 20px;
        }

        .category {
            margin-bottom: 20px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .category-header {
            background: #f8f9fa;
            padding: 10px 15px;
            border-bottom: 1px solid #ddd;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
        }

        .category-content {
            padding: 15px;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }

        .setting-item:last-child {
            border-bottom: none;
        }

        .setting-name {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #d63384;
        }

        .setting-value {
            font-family: 'Courier New', monospace;
            color: #198754;
        }

        .stats {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }

        .collapsed .category-content {
            display: none;
        }

        .preset-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 4px;
            margin-bottom: 20px;
        }

        .preset-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }

        .preset-select {
            flex: 1;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            max-height: 200px;
        }

        .preset-options {
            margin: 15px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #f8f9fa;
        }

        .preset-options h5 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #495057;
        }

        .option-item {
            margin: 8px 0;
            padding: 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            background: white;
        }

        .option-item.disabled {
            background: #f8f9fa;
            border-color: #e9ecef;
            opacity: 0.6;
        }

        .option-checkbox {
            margin-right: 8px;
        }

        .option-checkbox:disabled {
            cursor: not-allowed;
        }

        .option-label {
            font-weight: 500;
            color: #495057;
        }

        .option-label.disabled {
            color: #6c757d;
            cursor: not-allowed;
        }

        .option-settings {
            margin-top: 5px;
            font-size: 12px;
            color: #6c757d;
            font-family: 'Courier New', monospace;
        }

        .option-unsupported {
            color: #dc3545;
            font-style: italic;
            font-size: 11px;
        }

        .preset-controls button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .diff-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }

        .diff-changed {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
        }

        .diff-new {
            background: #d1ecf1;
            border-left: 4px solid #17a2b8;
        }

        .diff-unchanged {
            background: #f8f9fa;
            color: #6c757d;
        }

        .diff-value {
            font-weight: bold;
        }

        .diff-old {
            color: #dc3545;
        }

        .diff-new-value {
            color: #28a745;
            font-weight: bold;
        }

        .preset-info {
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 14px;
        }

        .preset-title {
            font-weight: bold;
            color: #495057;
        }

        .preset-description {
            margin-top: 5px;
            color: #6c757d;
        }

        .loading-status {
            color: #6c757d;
            font-style: italic;
        }

        .preset-controls button {
            min-width: 80px;
        }

        .compare-tabs {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .compare-side {
            flex: 1;
            min-width: 0;
        }

        .compare-middle {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px 15px;
            min-width: 120px;
        }

        .vs-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .vs-label {
            font-size: 24px;
            font-weight: bold;
            color: #007acc;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .compare-button {
            background: #28a745 !important;
            font-weight: bold;
            padding: 12px 16px;
            white-space: nowrap;
        }

        .compare-button:hover:not(:disabled) {
            background: #218838 !important;
        }

        .compare-button:disabled {
            background: #ccc !important;
        }

        .input-method-tabs {
            display: flex;
            margin-bottom: 10px;
            border-bottom: 2px solid #ddd;
        }

        .tab-button {
            background: none;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            font-size: 14px;
            color: #666;
            transition: all 0.2s;
        }

        .tab-button.active {
            color: #007acc;
            border-bottom-color: #007acc;
            font-weight: bold;
        }

        .tab-button:hover {
            background: #f8f9fa;
        }

        .input-method {
            display: none;
            margin-top: 15px;
        }

        .input-method.active {
            display: block;
        }

        .config-status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            font-size: 14px;
        }

        .config-loaded {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .config-error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .loading-status {
            text-align: center;
            padding: 10px;
            margin: 15px 0;
            background: #e9ecef;
            border-radius: 4px;
            font-style: italic;
            color: #6c757d;
        }

        @media (max-width: 768px) {
            .compare-tabs {
                flex-direction: column;
            }

            .compare-middle {
                order: 3;
                padding: 15px 0;
            }

            .vs-section {
                flex-direction: row;
                gap: 10px;
            }
        }

        .individual-configs {
            margin-top: 30px;
        }

        .config-details {
            display: flex;
            gap: 20px;
        }

        .config-detail {
            flex: 1;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
        }

        .config-detail h4 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #495057;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 8px;
        }

        @media (max-width: 768px) {
            .config-details {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Betaflight PID Tune Comparator</h1>

        <div class="input-section">
            <h3>Load Configurations to Compare</h3>

            <div class="compare-tabs">
                <div class="compare-side">
                    <h4>Configuration A</h4>
                    <div class="input-method-tabs">
                        <button class="tab-button active" onclick="switchInputMethod('A', 'text')">üìù CLI Text</button>
                        <button class="tab-button" onclick="switchInputMethod('A', 'preset')">üéØ PID Tune</button>
                    </div>

                    <div id="inputMethodA-text" class="input-method active">
                        <textarea class="cli-input" id="cliInputA" placeholder="Paste your CLI export here...

Example:
# Betaflight / STM32F405 (S405) 4.4.0 Feb 27 2023
set gyro_lpf1_static_hz = 250
set dyn_notch_count = 1
set p_pitch = 58
set i_pitch = 52
..."></textarea>
                        <button class="parse-button" onclick="loadConfigFromText('A')">Load Config A</button>
                    </div>

                    <div id="inputMethodA-preset" class="input-method">
                        <select id="presetSelectA" class="preset-select" size="8">
                            <option value="">Loading PID tunes...</option>
                        </select>
                        <div id="presetOptionsA" class="preset-options" style="display: none;">
                            <h5>Preset Options:</h5>
                            <div id="optionsListA"></div>
                        </div>
                    </div>

                    <div id="configStatusA" class="config-status" style="display: none;"></div>
                </div>

                <div class="compare-middle">
                    <div class="vs-section">
                        <div class="vs-label">VS</div>
                        <button class="parse-button compare-button" onclick="compareConfigs()" id="compareConfigsBtn" disabled>
                            üîç Compare A ‚Üî B
                        </button>
                        <button class="parse-button" onclick="clearAll()" id="clearAllBtn">üóëÔ∏è Clear All</button>
                    </div>
                </div>

                <div class="compare-side">
                    <h4>Configuration B</h4>
                    <div class="input-method-tabs">
                        <button class="tab-button active" onclick="switchInputMethod('B', 'text')">üìù CLI Text</button>
                        <button class="tab-button" onclick="switchInputMethod('B', 'preset')">üéØ PID Tune</button>
                    </div>

                    <div id="inputMethodB-text" class="input-method active">
                        <textarea class="cli-input" id="cliInputB" placeholder="Paste second CLI export here to compare..."></textarea>
                        <button class="parse-button" onclick="loadConfigFromText('B')">Load Config B</button>
                    </div>

                    <div id="inputMethodB-preset" class="input-method">
                        <select id="presetSelectB" class="preset-select" size="8">
                            <option value="">Loading PID tunes...</option>
                        </select>
                        <div id="presetOptionsB" class="preset-options" style="display: none;">
                            <h5>Preset Options:</h5>
                            <div id="optionsListB"></div>
                        </div>
                    </div>

                    <div id="configStatusB" class="config-status" style="display: none;"></div>
                </div>
            </div>

            <div id="loadingStatus" class="loading-status">
                üîÑ Loading PID tune presets from GitHub...
            </div>

            <div style="background: #e3f2fd; padding: 10px; border-radius: 4px; margin: 15px 0; font-size: 14px;">
                üí° <strong>Tip:</strong> Presets marked with ‚öôÔ∏è have configurable options (like battery voltage, link frequency, etc.)
                that will appear below the dropdown when selected.
            </div>

            <div class="debug-section" style="margin-top: 20px;">
                <details>
                    <summary style="cursor: pointer; color: #6c757d; font-size: 14px;">üîß Debug Info (click to expand)</summary>
                    <div id="debugInfo" style="margin-top: 10px; font-size: 12px; color: #6c757d; max-height: 200px; overflow-y: auto;"></div>
                </details>
            </div>
        </div>

        <div class="results-section" id="resultsSection" style="display: none;">
            <div class="stats" id="statsSection"></div>

            <div id="comparisonResults">
                <h3>Comparison Results</h3>
                <div id="comparisonDiff"></div>
            </div>

            <div class="individual-configs">
                <h3>Individual Configuration Details</h3>
                <div class="config-details">
                    <div class="config-detail" id="configDetailsA" style="display: none;">
                        <h4>Configuration A Settings</h4>
                        <div id="categorizedSettingsA"></div>
                    </div>

                    <div class="config-detail" id="configDetailsB" style="display: none;">
                        <h4>Configuration B Settings</h4>
                        <div id="categorizedSettingsB"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class BetaflightCLIParser {
            constructor() {
                this.settings = new Map();
                this.categories = this.initializeCategories();
                this.presets = this.initializePresets();
            }

            initializePresets() {
                return {}; // Will be populated dynamically
            }

            async loadPresetsFromGitHub() {
                try {
                    const categories = ['tune']; // Only load TUNE presets
                    const versions = ['4.3', '4.4', '4.5'];
                    const loadedPresets = {};
                    let totalAttempted = 0;
                    let totalLoaded = 0;

                    for (const version of versions) {
                        for (const category of categories) {
                            try {
                                const dirUrl = `https://api.github.com/repos/betaflight/firmware-presets/contents/presets/${version}/${category}`;
                                const response = await fetch(dirUrl);

                                if (!response.ok) {
                                    console.log(`No ${category} directory found for version ${version}`);
                                    continue;
                                }

                                const files = await response.json();
                                const txtFiles = files.filter(f => f.name.endsWith('.txt'));
                                console.log(`Found ${txtFiles.length} .txt files in ${version}/${category}`);

                                // Load ALL tune files (remove the 15 limit for tune category)
                                totalAttempted += txtFiles.length;

                                for (const file of txtFiles) {
                                    try {
                                        // Skip utility files before fetching
                                        const utilityFiles = ['blackbox_disable', 'reset_servo', 'defaults_tune_filters', 'defaults_', 'reset_all', 'reset_some', 'reset_'];
                                        if (utilityFiles.some(util => file.name.toLowerCase().includes(util))) {
                                            continue; // Skip silently
                                        }

                                        const presetResponse = await fetch(file.download_url);
                                        if (!presetResponse.ok) {
                                            console.warn(`Failed to fetch ${file.name}: ${presetResponse.status}`);
                                            continue;
                                        }

                                        const presetContent = await presetResponse.text();
                                        const parsedPreset = this.parsePresetFile(presetContent, file.name, category, version);

                                        if (parsedPreset) {
                                            const key = `${version}_${category}_${file.name.replace('.txt', '')}`;
                                            loadedPresets[key] = parsedPreset;
                                            totalLoaded++;
                                            console.log(`‚úì Loaded: ${parsedPreset.title} (${file.name})`);
                                        } else {
                                            console.warn(`Failed to parse ${file.name} - no relevant tune settings found`);
                                        }
                                    } catch (e) {
                                        console.warn(`Failed to load preset ${file.name}:`, e);
                                    }
                                }
                            } catch (e) {
                                console.warn(`Failed to load ${category} presets for ${version}:`, e);
                            }
                        }
                    }

                    console.log(`Successfully loaded ${totalLoaded} out of ${totalAttempted} attempted tune presets`);
                    this.presets = loadedPresets;
                    return totalLoaded;
                } catch (error) {
                    console.error('Failed to load presets from GitHub:', error);
                    // Fallback to basic presets
                    this.presets = this.getFallbackPresets();
                    return Object.keys(this.presets).length;
                }
            }

            parsePresetFile(content, filename, category, version) {
                try {
                    const lines = content.split('\n');
                    const metadata = {};
                    const settings = {};
                    const options = [];

                    let inOptionBlock = false;
                    let currentOption = null;
                    let inIncludeBlock = false;

                    for (const line of lines) {
                        const trimmed = line.trim();

                        // Parse metadata
                        if (trimmed.startsWith('#$ TITLE:')) {
                            metadata.title = trimmed.substring(9).trim();
                        } else if (trimmed.startsWith('#$ DESCRIPTION:')) {
                            const desc = trimmed.substring(15).trim();
                            if (desc && !desc.includes('<') && desc.length < 300) {
                                metadata.description = (metadata.description || '') + desc + ' ';
                            }
                        } else if (trimmed.startsWith('#$ CATEGORY:')) {
                            metadata.category = trimmed.substring(12).trim();
                        } else if (trimmed.startsWith('#$ AUTHOR:')) {
                            metadata.author = trimmed.substring(10).trim();
                        } else if (trimmed.startsWith('#$ STATUS:')) {
                            metadata.status = trimmed.substring(10).trim();
                        }

                        // Handle includes (we'll skip these for now)
                        if (trimmed.startsWith('#$ INCLUDE:')) {
                            inIncludeBlock = true;
                            continue;
                        }

                        // Handle option blocks - now we'll parse them!
                        if (trimmed.startsWith('#$ OPTION BEGIN')) {
                            inOptionBlock = true;
                            const optionMatch = trimmed.match(/^#\$\s*OPTION\s+BEGIN\s*(?:\((CHECKED|UNCHECKED)\))?\s*:\s*(.+)$/);
                            if (optionMatch) {
                                currentOption = {
                                    name: optionMatch[2].trim(),
                                    checked: optionMatch[1] === 'CHECKED',
                                    settings: {}
                                };
                            }
                            continue;
                        } else if (trimmed.startsWith('#$ OPTION END')) {
                            if (currentOption) {
                                options.push(currentOption);
                                currentOption = null;
                            }
                            inOptionBlock = false;
                            continue;
                        }

                        // Parse set commands
                        if (trimmed.startsWith('set ')) {
                            const setMatch = trimmed.match(/^set\s+([a-zA-Z0-9_]+)\s*=\s*(.+)$/);
                            if (setMatch) {
                                if (inOptionBlock && currentOption) {
                                    // Add to current option
                                    currentOption.settings[setMatch[1]] = setMatch[2].trim();
                                } else {
                                    // Add to main settings
                                    settings[setMatch[1]] = setMatch[2].trim();
                                }
                            }
                        }
                    }

                    // Generate title from filename if no title found
                    if (!metadata.title) {
                        metadata.title = filename.replace('.txt', '').replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    }

                    // Check if this looks like a legitimate tune file
                    const hasRelevantSettings = Object.keys(settings).some(key =>
                        key.includes('_pitch') || key.includes('_roll') || key.includes('_yaw') ||
                        key.includes('dyn_notch') || key.includes('gyro_lpf') ||
                        key.includes('feedforward') || key.includes('dterm') ||
                        key.includes('vbat_sag') || key.includes('thrust_linear')
                    ) || options.length > 0;

                    // Only return if we have meaningful data OR if it's clearly a tune file
                    if ((Object.keys(settings).length > 0 || options.length > 0) && (metadata.title || hasRelevantSettings)) {
                        return {
                            title: metadata.title,
                            description: (metadata.description || '').trim() || `PID tune for Betaflight ${version} (${filename})`,
                            category: metadata.category || 'TUNE',
                            author: metadata.author || 'Unknown',
                            status: metadata.status || 'COMMUNITY',
                            version: version,
                            filename: filename,
                            settings: settings,
                            options: options
                        };
                    }

                    return null;
                } catch (error) {
                    console.warn(`Failed to parse preset file ${filename}:`, error);
                    return null;
                }
            }

            getFallbackPresets() {
                return {
                    'basic_freestyle': {
                        title: 'Basic Freestyle Tune',
                        description: 'Conservative freestyle PID tune that works for most 5" quads',
                        category: 'TUNE',
                        author: 'Fallback',
                        version: '4.3',
                        settings: {
                            'p_pitch': '58', 'i_pitch': '52', 'd_pitch': '52', 'f_pitch': '145',
                            'p_roll': '55', 'i_roll': '50', 'd_roll': '48', 'f_roll': '138',
                            'p_yaw': '55', 'i_yaw': '50', 'd_yaw': '0', 'f_yaw': '138'
                        },
                        options: [
                            {
                                name: 'High Battery Voltage (4.35V)',
                                checked: false,
                                settings: {
                                    'vbat_max_cell_voltage': '435',
                                    'vbat_warning_cell_voltage': '350'
                                }
                            },
                            {
                                name: 'Race Mode Settings',
                                checked: false,
                                settings: {
                                    'p_pitch': '65',
                                    'i_pitch': '65',
                                    'd_pitch': '60'
                                }
                            }
                        ]
                    },
                    'basic_race': {
                        title: 'Basic Race Tune',
                        description: 'Aggressive racing PID tune with higher gains',
                        category: 'TUNE',
                        author: 'Fallback',
                        version: '4.3',
                        settings: {
                            'p_pitch': '70', 'i_pitch': '125', 'd_pitch': '65', 'f_pitch': '270',
                            'p_roll': '65', 'i_roll': '120', 'd_roll': '60', 'f_roll': '250',
                            'p_yaw': '65', 'i_yaw': '120', 'd_yaw': '0', 'f_yaw': '250'
                        },
                        options: []
                    }
                };
            }

            initializeCategories() {
                return {
                    'PID Controller': ['pid_process_denom', 'gyro_lpf1_static_hz', 'gyro_lpf1_dyn_min_hz', 'gyro_lpf1_dyn_max_hz', 'dyn_notch_count', 'dyn_notch_q', 'dyn_notch_min_hz', 'dyn_notch_max_hz'],
                    'PID Tuning': ['p_pitch', 'i_pitch', 'd_pitch', 'p_roll', 'i_roll', 'd_roll', 'p_yaw', 'i_yaw', 'd_yaw', 'f_pitch', 'f_roll', 'f_yaw'],
                    'RC Rates': ['rc_smoothing_type', 'rc_smoothing_input_hz', 'rc_smoothing_derivative_hz', 'serialrx_provider', 'sbus_inversion'],
                    'Rates': ['roll_rc_rate', 'pitch_rc_rate', 'yaw_rc_rate', 'roll_expo', 'pitch_expo', 'yaw_expo', 'roll_srate', 'pitch_srate', 'yaw_srate'],
                    'Motors': ['motor_pwm_protocol', 'motor_pwm_rate', 'motor_poles', 'thrust_linear'],
                    'Battery & Power': ['bat_capacity', 'vbat_max_cell_voltage', 'vbat_min_cell_voltage', 'vbat_warning_cell_voltage', 'ibata_scale', 'ibata_offset'],
                    'OSD': ['osd_vbat_pos', 'osd_rssi_pos', 'osd_tim_1_pos', 'osd_tim_2_pos', 'osd_remaining_time_estimate_pos', 'osd_flymode_pos'],
                    'Failsafe': ['failsafe_delay', 'failsafe_off_delay', 'failsafe_throttle', 'failsafe_switch_mode', 'failsafe_throttle_low_delay'],
                    'GPS': ['gps_provider', 'gps_sbas_mode', 'gps_auto_config', 'gps_auto_baud', 'gps_ublox_use_galileo'],
                    'Blackbox': ['blackbox_device', 'blackbox_record_acc', 'blackbox_mode'],
                    'System': ['gyro_hardware_lpf', 'gyro_32khz_hardware_lpf', 'gyro_sync_denom', 'scheduler_optimize_rate'],
                    'Other': [] // Will catch anything not categorized above
                };
            }

            parse(cliText) {
                this.settings.clear();
                const lines = cliText.split('\n');
                let parsedCount = 0;

                for (const line of lines) {
                    const trimmed = line.trim();

                    // Skip empty lines and comments
                    if (!trimmed || trimmed.startsWith('#')) {
                        continue;
                    }

                    // Parse 'set' commands
                    if (trimmed.startsWith('set ')) {
                        const result = this.parseSetCommand(trimmed);
                        if (result) {
                            this.settings.set(result.parameter, result.value);
                            parsedCount++;
                        }
                    }
                }

                return {
                    success: true,
                    settingsCount: parsedCount,
                    totalLines: lines.length,
                    settings: this.settings
                };
            }

            parseSetCommand(line) {
                // Match: set parameter_name = value
                const match = line.match(/^set\s+([a-zA-Z0-9_]+)\s*=\s*(.+)$/);
                if (match) {
                    return {
                        parameter: match[1].trim(),
                        value: match[2].trim()
                    };
                }
                return null;
            }

            categorizeSettings() {
                const categorized = {};
                const foundSettings = new Set();

                // Initialize all categories
                for (const [categoryName, parameters] of Object.entries(this.categories)) {
                    categorized[categoryName] = [];
                }

                // Categorize known settings
                for (const [categoryName, parameters] of Object.entries(this.categories)) {
                    if (categoryName === 'Other') continue; // Skip 'Other' for now

                    for (const param of parameters) {
                        if (this.settings.has(param)) {
                            categorized[categoryName].push({
                                parameter: param,
                                value: this.settings.get(param)
                            });
                            foundSettings.add(param);
                        }
                    }
                }

                // Put uncategorized settings in 'Other'
                for (const [param, value] of this.settings) {
                    if (!foundSettings.has(param)) {
                        categorized['Other'].push({
                            parameter: param,
                            value: value
                        });
                    }
                }

                // Remove empty categories
                for (const categoryName of Object.keys(categorized)) {
                    if (categorized[categoryName].length === 0) {
                        delete categorized[categoryName];
                    }
                }

                return categorized;
            }

            compareWithPreset(presetKey) {
                const preset = this.presets[presetKey];
                if (!preset) return null;

                const changes = [];
                const presetSettings = new Map(Object.entries(preset.settings));

                // Find all parameters that would change
                for (const [param, newValue] of presetSettings) {
                    const currentValue = this.settings.get(param);

                    if (currentValue === undefined) {
                        // New parameter
                        changes.push({
                            parameter: param,
                            type: 'new',
                            currentValue: null,
                            newValue: newValue
                        });
                    } else if (currentValue !== newValue) {
                        // Changed parameter
                        changes.push({
                            parameter: param,
                            type: 'changed',
                            currentValue: currentValue,
                            newValue: newValue
                        });
                    } else {
                        // Unchanged parameter
                        changes.push({
                            parameter: param,
                            type: 'unchanged',
                            currentValue: currentValue,
                            newValue: newValue
                        });
                    }
                }

                return {
                    preset: preset,
                    changes: changes
                };
            }
        }

        const parser = new BetaflightCLIParser();
        let presetsLoaded = false;
        let configA = null;
        let configB = null;

        // Load presets immediately when page loads
        window.addEventListener('DOMContentLoaded', function() {
            loadPresets();
        });

        async function loadPresets() {
            const loadingStatus = document.getElementById('loadingStatus');
            const debugInfo = document.getElementById('debugInfo');

            try {
                loadingStatus.innerHTML = 'üîÑ Loading PID tune presets from GitHub...';
                debugInfo.innerHTML = 'Starting tune preset load...<br>';

                const count = await parser.loadPresetsFromGitHub();

                // Update both preset dropdowns
                populatePresetDropdowns();

                loadingStatus.innerHTML = `‚úÖ Loaded ${count} PID tune presets from official Betaflight repository`;
                loadingStatus.style.color = '#28a745';

                // Add debug info about loaded presets
                let debugText = `<strong>Total TUNE presets loaded: ${count}</strong><br><br>`;
                debugText += '<strong>Loaded tune presets:</strong><br>';

                const groupedPresets = {};
                for (const [key, preset] of Object.entries(parser.presets)) {
                    const groupKey = `Betaflight ${preset.version}`;
                    if (!groupedPresets[groupKey]) {
                        groupedPresets[groupKey] = [];
                    }
                    groupedPresets[groupKey].push(preset);
                }

                for (const [group, presets] of Object.entries(groupedPresets)) {
                    debugText += `<br><u>${group} (${presets.length} presets):</u><br>`;
                    presets.sort((a, b) => a.title.localeCompare(b.title));
                    for (const preset of presets) {
                        const optionsInfo = preset.options && preset.options.length > 0 ? ` [${preset.options.length} options]` : '';
                        debugText += `‚Ä¢ ${preset.title} by ${preset.author} (${preset.filename})${optionsInfo}<br>`;
                    }
                }

                debugText += '<br><strong>Looking for a specific tune?</strong><br>';
                debugText += '‚Ä¢ Try searching in the search box above<br>';
                debugText += '‚Ä¢ Some tunes might be in different versions (4.2, 4.1, etc.)<br>';
                debugText += '‚Ä¢ Check the filenames - they might be named differently<br>';
                debugText += '‚Ä¢ Not all Betaflight Configurator presets are in the GitHub repo<br>';

                debugInfo.innerHTML = debugText;

                // Hide loading status after 3 seconds
                setTimeout(() => {
                    loadingStatus.style.display = 'none';
                }, 3000);

                presetsLoaded = true;
            } catch (error) {
                console.error('Failed to load presets:', error);
                loadingStatus.innerHTML = '‚ùå Failed to load presets - using fallback PID tunes';
                loadingStatus.style.color = '#dc3545';

                debugInfo.innerHTML = `Error loading presets: ${error.message}<br>Using fallback PID tunes instead.`;

                populatePresetDropdowns();
            }
        }

        function populatePresetDropdowns() {
            const selectA = document.getElementById('presetSelectA');
            const selectB = document.getElementById('presetSelectB');

            [selectA, selectB].forEach(select => {
                select.innerHTML = '<option value="">Select a tune preset...</option>';

                // Group presets by version only (since all are TUNE category)
                const grouped = {};
                for (const [key, preset] of Object.entries(parser.presets)) {
                    const groupKey = `Betaflight ${preset.version}`;
                    if (!grouped[groupKey]) {
                        grouped[groupKey] = [];
                    }
                    grouped[groupKey].push({key, preset});
                }

                // Sort presets within each group alphabetically
                for (const groupKey in grouped) {
                    grouped[groupKey].sort((a, b) => a.preset.title.localeCompare(b.preset.title));
                }

                // Add grouped options
                for (const [groupName, presets] of Object.entries(grouped)) {
                    if (presets.length > 0) {
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = groupName;

                        for (const {key, preset} of presets) {
                            const option = document.createElement('option');
                            option.value = key;
                            const optionsIndicator = preset.options && preset.options.length > 0 ? ` ‚öôÔ∏è ${preset.options.length}` : '';
                            option.textContent = `${preset.title}${preset.author ? ` (${preset.author})` : ''}${optionsIndicator}`;
                            optgroup.appendChild(option);
                        }

                        select.appendChild(optgroup);
                    }
                }
            });

            // Add event listeners
            document.getElementById('presetSelectA').addEventListener('change', function() {
                console.log('Preset A changed to:', this.value);
                if (this.value) {
                    showPresetOptions('A', this.value);
                } else {
                    hidePresetOptions('A');
                    configA = null;
                    document.getElementById('configStatusA').style.display = 'none';
                    updateCompareButton();
                }
            });

            document.getElementById('presetSelectB').addEventListener('change', function() {
                console.log('Preset B changed to:', this.value);
                if (this.value) {
                    showPresetOptions('B', this.value);
                } else {
                    hidePresetOptions('B');
                    configB = null;
                    document.getElementById('configStatusB').style.display = 'none';
                    updateCompareButton();
                }
            });
        }

        function showPresetOptions(side, presetKey) {
            const preset = parser.presets[presetKey];
            const optionsDiv = document.getElementById(`presetOptions${side}`);
            const optionsListDiv = document.getElementById(`optionsList${side}`);

            if (!preset || !preset.options || preset.options.length === 0) {
                hidePresetOptions(side);
                return;
            }

            console.log(`Showing ${preset.options.length} options for preset ${presetKey} on side ${side}`);

            // Build options HTML
            let html = '';
            let supportedCount = 0;
            let unsupportedCount = 0;

            preset.options.forEach((option, index) => {
                const optionId = `option_${side}_${index}`;
                const hasSettings = option.settings && Object.keys(option.settings).length > 0;

                if (hasSettings) {
                    supportedCount++;
                    const settingsPreview = Object.entries(option.settings).slice(0, 3).map(([key, value]) =>
                        `${key} = ${value}`
                    ).join(', ');
                    const moreSettings = Object.keys(option.settings).length > 3 ? ` (+${Object.keys(option.settings).length - 3} more)` : '';

                    console.log(`Creating checkbox ${optionId} for option "${option.name}" (default: ${option.checked}) - SUPPORTED`);

                    html += `
                        <div class="option-item">
                            <label>
                                <input type="checkbox" class="option-checkbox" id="${optionId}" ${option.checked ? 'checked' : ''}
                                       onchange="onOptionChanged('${side}')">
                                <span class="option-label">${option.name}</span>
                            </label>
                            <div class="option-settings">${settingsPreview}${moreSettings}</div>
                        </div>
                    `;
                } else {
                    unsupportedCount++;
                    console.log(`Creating disabled checkbox ${optionId} for option "${option.name}" - UNSUPPORTED (no settings)`);

                    html += `
                        <div class="option-item disabled">
                            <label>
                                <input type="checkbox" class="option-checkbox" id="${optionId}" disabled
                                       title="This option uses advanced preset features (includes, templates, etc.) that are not supported by this comparator">
                                <span class="option-label disabled">${option.name}</span>
                            </label>
                            <div class="option-unsupported">‚ö†Ô∏è Unsupported: Uses advanced preset templating (includes, variables, etc.)</div>
                        </div>
                    `;
                }
            });

            // Add summary at the top
            if (unsupportedCount > 0) {
                html = `
                    <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; padding: 8px; margin-bottom: 10px; font-size: 12px;">
                        üìä <strong>Options Summary:</strong> ${supportedCount} supported, ${unsupportedCount} unsupported<br>
                        <small style="color: #856404;">Unsupported options use advanced Betaflight preset features that require the full Configurator processing engine.</small>
                    </div>
                ` + html;
            }

            optionsListDiv.innerHTML = html;
            optionsDiv.style.display = 'block';

            // Immediately load the config with default option states (only for supported options)
            loadConfigFromPreset(side);
        }

        function hidePresetOptions(side) {
            const optionsDiv = document.getElementById(`presetOptions${side}`);
            optionsDiv.style.display = 'none';
        }

        function onOptionChanged(side) {
            // Reload the config with the new option selections
            loadConfigFromPreset(side);
        }

        function switchInputMethod(side, method) {
            // Update tab buttons
            const tabs = document.querySelectorAll(`#inputMethod${side}-text`).length > 0 ?
                document.querySelectorAll(`.input-method-tabs button`) : [];

            document.querySelectorAll(`.compare-side:nth-child(${side === 'A' ? '1' : '3'}) .tab-button`).forEach(btn => {
                btn.classList.remove('active');
            });

            document.querySelector(`.compare-side:nth-child(${side === 'A' ? '1' : '3'}) .tab-button:nth-child(${method === 'text' ? '1' : '2'})`).classList.add('active');

            // Update input method visibility
            document.getElementById(`inputMethod${side}-text`).classList.toggle('active', method === 'text');
            document.getElementById(`inputMethod${side}-preset`).classList.toggle('active', method === 'preset');
        }

        function loadConfigFromText(side) {
            const textArea = document.getElementById(`cliInput${side}`);
            const statusDiv = document.getElementById(`configStatus${side}`);

            if (!textArea.value.trim()) {
                alert(`Please paste some CLI export data in Configuration ${side} first!`);
                return;
            }

            try {
                // Create a temporary parser instance to avoid conflicts
                const tempParser = new BetaflightCLIParser();
                const result = tempParser.parse(textArea.value);

                const config = {
                    type: 'text',
                    title: `Custom CLI Export ${side}`,
                    description: 'Loaded from CLI text',
                    settings: new Map(tempParser.settings), // Create a new Map copy
                    metadata: {
                        settingsCount: result.settingsCount,
                        totalLines: result.totalLines
                    }
                };

                if (side === 'A') {
                    configA = config;
                } else {
                    configB = config;
                }

                statusDiv.innerHTML = `‚úÖ Loaded ${result.settingsCount} settings from ${result.totalLines} lines`;
                statusDiv.className = 'config-status config-loaded';
                statusDiv.style.display = 'block';

                updateCompareButton();

            } catch (error) {
                statusDiv.innerHTML = `‚ùå Error parsing CLI: ${error.message}`;
                statusDiv.className = 'config-status config-error';
                statusDiv.style.display = 'block';
            }
        }

        function loadConfigFromPreset(side) {
            const presetSelect = document.getElementById(`presetSelect${side}`);
            const statusDiv = document.getElementById(`configStatus${side}`);
            const selectedPreset = presetSelect.value;

            if (!selectedPreset) {
                if (side === 'A') {
                    configA = null;
                } else {
                    configB = null;
                }
                statusDiv.style.display = 'none';
                updateCompareButton();
                return;
            }

            const preset = parser.presets[selectedPreset];
            if (!preset) {
                statusDiv.innerHTML = `‚ùå PID tune not found`;
                statusDiv.className = 'config-status config-error';
                statusDiv.style.display = 'block';
                return;
            }

            // Start with the base preset settings
            const finalSettings = new Map(Object.entries(preset.settings));
            console.log(`${side}: Starting with base settings:`, Object.keys(preset.settings));

            // Apply selected options
            const appliedOptions = [];
            if (preset.options && preset.options.length > 0) {
                console.log(`${side}: Checking ${preset.options.length} available options...`);
                preset.options.forEach((option, index) => {
                    const optionCheckbox = document.getElementById(`option_${side}_${index}`);
                    const isChecked = optionCheckbox && optionCheckbox.checked;
                    console.log(`${side}: Option ${index} "${option.name}" - checkbox exists: ${!!optionCheckbox}, checked: ${isChecked}`);

                    if (isChecked) {
                        // Add option settings to final settings (these will override base settings if same parameter)
                        for (const [key, value] of Object.entries(option.settings)) {
                            const oldValue = finalSettings.get(key);
                            finalSettings.set(key, value);
                            console.log(`${side}: Option "${option.name}" set ${key}: ${oldValue} ‚Üí ${value}`);
                        }
                        appliedOptions.push(option.name);
                    }
                });
            }

            const config = {
                type: 'preset',
                title: preset.title,
                description: preset.description,
                settings: finalSettings,
                metadata: {
                    author: preset.author,
                    category: preset.category,
                    version: preset.version,
                    filename: preset.filename,
                    optionsApplied: appliedOptions
                }
            };

            if (side === 'A') {
                configA = config;
            } else {
                configB = config;
            }

            const appliedOptionsText = appliedOptions.length > 0 ?
                ` (with ${appliedOptions.length} options: ${appliedOptions.join(', ')})` : '';

            statusDiv.innerHTML = `‚úÖ Loaded PID tune: ${preset.title}${appliedOptionsText}<br>Base settings: ${Object.keys(preset.settings).length}, Final settings: ${finalSettings.size}`;
            statusDiv.className = 'config-status config-loaded';
            statusDiv.style.display = 'block';

            updateCompareButton();
        }

        function updateCompareButton() {
            const compareBtn = document.getElementById('compareConfigsBtn');
            compareBtn.disabled = !(configA && configB);
        }

        function compareConfigs() {
            if (!configA || !configB) {
                alert('Please load both Configuration A and Configuration B first!');
                return;
            }

            // Debug: Log the final settings for both configs
            console.log('=== COMPARISON DEBUG ===');
            console.log('Config A final settings:', Array.from(configA.settings.entries()));
            console.log('Config B final settings:', Array.from(configB.settings.entries()));

            // Debug: Check for specific parameters that should differ
            const testParams = ['p_pitch', 'i_pitch', 'd_pitch', 'vbat_max_cell_voltage', 'vbat_warning_cell_voltage'];
            testParams.forEach(param => {
                const valueA = configA.settings.get(param);
                const valueB = configB.settings.get(param);
                if (valueA !== valueB) {
                    console.log(`Parameter ${param}: A="${valueA}" vs B="${valueB}" - DIFFERENT`);
                } else if (valueA !== undefined) {
                    console.log(`Parameter ${param}: A="${valueA}" vs B="${valueB}" - SAME`);
                }
            });

            const comparison = compareConfigurations(configA, configB);
            displayConfigComparison(comparison);

            // Show individual config details
            showConfigDetails();

            document.getElementById('resultsSection').style.display = 'block';
        }

        function compareConfigurations(configA, configB) {
            const changes = [];
            const settingsA = configA.settings;
            const settingsB = configB.settings;

            // Get all unique parameters from both configs
            const allParams = new Set([...settingsA.keys(), ...settingsB.keys()]);

            for (const param of allParams) {
                const valueA = settingsA.get(param);
                const valueB = settingsB.get(param);

                if (valueA === undefined && valueB !== undefined) {
                    changes.push({
                        parameter: param,
                        type: 'only_b',
                        valueA: null,
                        valueB: valueB
                    });
                } else if (valueA !== undefined && valueB === undefined) {
                    changes.push({
                        parameter: param,
                        type: 'only_a',
                        valueA: valueA,
                        valueB: null
                    });
                } else if (valueA !== valueB) {
                    changes.push({
                        parameter: param,
                        type: 'different',
                        valueA: valueA,
                        valueB: valueB
                    });
                } else {
                    changes.push({
                        parameter: param,
                        type: 'same',
                        valueA: valueA,
                        valueB: valueB
                    });
                }
            }

            return {
                configA: configA,
                configB: configB,
                changes: changes
            };
        }

        function displayConfigComparison(comparison) {
            const statsSection = document.getElementById('statsSection');
            const comparisonDiff = document.getElementById('comparisonDiff');

            const different = comparison.changes.filter(c => c.type === 'different');
            const onlyA = comparison.changes.filter(c => c.type === 'only_a');
            const onlyB = comparison.changes.filter(c => c.type === 'only_b');
            const same = comparison.changes.filter(c => c.type === 'same');

            // Debug logging for troubleshooting
            console.log('Comparison results:', {
                different: different.length,
                onlyA: onlyA.length,
                onlyB: onlyB.length,
                same: same.length,
                configA_settings: comparison.configA.settings.size,
                configB_settings: comparison.configB.settings.size
            });

            if (different.length > 0) {
                console.log('Different parameters:', different.map(d => `${d.parameter}: A="${d.valueA}" vs B="${d.valueB}"`));
            }

            // Show summary
            statsSection.innerHTML = `
                <strong>Comparison Summary:</strong><br>
                üìä ${different.length} different values |
                üÖ∞Ô∏è ${onlyA.length} only in A |
                üÖ±Ô∏è ${onlyB.length} only in B |
                ‚úÖ ${same.length} identical<br>
                <small style="color: #6c757d;">Config A: ${comparison.configA.settings.size} settings | Config B: ${comparison.configB.settings.size} settings</small>
            `;

            let html = `
                <div class="preset-info">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 15px;">
                        <div>
                            <div class="preset-title">A: ${comparison.configA.title}</div>
                            <div class="preset-description">${comparison.configA.description}</div>
                            ${comparison.configA.metadata && comparison.configA.metadata.optionsApplied && comparison.configA.metadata.optionsApplied.length > 0 ?
                                `<div style="font-size: 12px; color: #007acc; margin-top: 5px;">Options: ${comparison.configA.metadata.optionsApplied.join(', ')}</div>` : ''}
                        </div>
                        <div style="text-align: right;">
                            <div class="preset-title">B: ${comparison.configB.title}</div>
                            <div class="preset-description">${comparison.configB.description}</div>
                            ${comparison.configB.metadata && comparison.configB.metadata.optionsApplied && comparison.configB.metadata.optionsApplied.length > 0 ?
                                `<div style="font-size: 12px; color: #28a745; margin-top: 5px;">Options: ${comparison.configB.metadata.optionsApplied.join(', ')}</div>` : ''}
                        </div>
                    </div>
                </div>
            `;

            if (different.length > 0) {
                html += '<h5>üîÑ Parameters with different values:</h5>';
                // Sort different parameters to show PID parameters first
                different.sort((a, b) => {
                    const pidParams = ['p_pitch', 'i_pitch', 'd_pitch', 'p_roll', 'i_roll', 'd_roll', 'p_yaw', 'i_yaw', 'd_yaw', 'f_pitch', 'f_roll', 'f_yaw'];
                    const aIsPid = pidParams.includes(a.parameter);
                    const bIsPid = pidParams.includes(b.parameter);
                    if (aIsPid && !bIsPid) return -1;
                    if (!aIsPid && bIsPid) return 1;
                    return a.parameter.localeCompare(b.parameter);
                });

                for (const change of different) {
                    const isPidParam = ['p_pitch', 'i_pitch', 'd_pitch', 'p_roll', 'i_roll', 'd_roll', 'p_yaw', 'i_yaw', 'd_yaw', 'f_pitch', 'f_roll', 'f_yaw'].includes(change.parameter);
                    const highlightClass = isPidParam ? 'style="background: #fffbf0; border-left-color: #ff9800;"' : '';

                    html += `
                        <div class="diff-item diff-changed" ${highlightClass}>
                            <span class="setting-name">${change.parameter}</span>
                            <span class="diff-value">
                                <span style="color: #007acc;">A:</span> <span class="diff-old">${change.valueA}</span> |
                                <span style="color: #28a745;">B:</span> <span class="diff-new-value">${change.valueB}</span>
                            </span>
                        </div>
                    `;
                }
            }

            if (onlyA.length > 0) {
                html += '<h5>üÖ∞Ô∏è Parameters only in Configuration A:</h5>';
                for (const change of onlyA) {
                    html += `
                        <div class="diff-item" style="background: #cce5ff; border-left: 4px solid #007acc;">
                            <span class="setting-name">${change.parameter}</span>
                            <span class="diff-value" style="color: #007acc;">${change.valueA}</span>
                        </div>
                    `;
                }
            }

            if (onlyB.length > 0) {
                html += '<h5>üÖ±Ô∏è Parameters only in Configuration B:</h5>';
                for (const change of onlyB) {
                    html += `
                        <div class="diff-item" style="background: #d4edda; border-left: 4px solid #28a745;">
                            <span class="setting-name">${change.parameter}</span>
                            <span class="diff-value" style="color: #28a745;">${change.valueB}</span>
                        </div>
                    `;
                }
            }

            if (same.length > 0 && same.length <= 15) {
                html += '<h5>‚úÖ Parameters with identical values:</h5>';
                for (const change of same) {
                    html += `
                        <div class="diff-item diff-unchanged">
                            <span class="setting-name">${change.parameter}</span>
                            <span class="diff-value">${change.valueA}</span>
                        </div>
                    `;
                }
            } else if (same.length > 15) {
                html += `<h5>‚úÖ ${same.length} parameters have identical values</h5>`;
            }

            if (different.length === 0 && onlyA.length === 0 && onlyB.length === 0) {
                html += '<div class="diff-item diff-unchanged">üéâ Configurations are identical!</div>';
            }

            comparisonDiff.innerHTML = html;
        }

        function showConfigDetails() {
            if (configA) {
                const categorizedA = categorizeSettings(configA.settings);
                document.getElementById('categorizedSettingsA').innerHTML = renderCategorizedSettings(categorizedA);
                document.getElementById('configDetailsA').style.display = 'block';
            }

            if (configB) {
                const categorizedB = categorizeSettings(configB.settings);
                document.getElementById('categorizedSettingsB').innerHTML = renderCategorizedSettings(categorizedB);
                document.getElementById('configDetailsB').style.display = 'block';
            }
        }

        function categorizeSettings(settings) {
            const categories = parser.categories;
            const categorized = {};
            const foundSettings = new Set();

            // Initialize all categories
            for (const [categoryName, parameters] of Object.entries(categories)) {
                categorized[categoryName] = [];
            }

            // Categorize known settings
            for (const [categoryName, parameters] of Object.entries(categories)) {
                if (categoryName === 'Other') continue;

                for (const param of parameters) {
                    if (settings.has(param)) {
                        categorized[categoryName].push({
                            parameter: param,
                            value: settings.get(param)
                        });
                        foundSettings.add(param);
                    }
                }
            }

            // Put uncategorized settings in 'Other'
            for (const [param, value] of settings) {
                if (!foundSettings.has(param)) {
                    categorized['Other'].push({
                        parameter: param,
                        value: value
                    });
                }
            }

            // Remove empty categories
            for (const categoryName of Object.keys(categorized)) {
                if (categorized[categoryName].length === 0) {
                    delete categorized[categoryName];
                }
            }

            return categorized;
        }

        function clearAll() {
            // Clear configurations
            configA = null;
            configB = null;

            // Clear inputs
            document.getElementById('cliInputA').value = '';
            document.getElementById('cliInputB').value = '';
            document.getElementById('presetSelectA').value = '';
            document.getElementById('presetSelectB').value = '';

            // Hide preset options
            hidePresetOptions('A');
            hidePresetOptions('B');

            // Clear status
            document.getElementById('configStatusA').style.display = 'none';
            document.getElementById('configStatusB').style.display = 'none';

            // Clear results
            document.getElementById('resultsSection').style.display = 'none';
            document.getElementById('configDetailsA').style.display = 'none';
            document.getElementById('configDetailsB').style.display = 'none';

            // Update compare button
            updateCompareButton();
        }

        function renderCategorizedSettings(categorized) {
            let html = '';

            for (const [categoryName, settings] of Object.entries(categorized)) {
                html += `
                    <div class="category">
                        <div class="category-header" onclick="toggleCategory(this)">
                            ${categoryName} (${settings.length} settings)
                        </div>
                        <div class="category-content">
                `;

                for (const setting of settings) {
                    html += `
                        <div class="setting-item">
                            <span class="setting-name">${setting.parameter}</span>
                            <span class="setting-value">${setting.value}</span>
                        </div>
                    `;
                }

                html += `
                        </div>
                    </div>
                `;
            }

            return html;
        }

        function toggleCategory(header) {
            const category = header.parentElement;
            category.classList.toggle('collapsed');
        }
    </script>
</body>
</html>
