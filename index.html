<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Betaflight PID Tune Comparator</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="app-container">
        <header class="header">
            <div class="header-content">
                <a href="#" class="logo">Betaflight PID Comparator</a>
                <div class="header-actions">
                    <button class="btn btn-primary" id="compareBtn" disabled>
                        Compare
                    </button>
                    <button class="btn btn-secondary" id="clearBtn">
                        Clear All
                    </button>

                </div>
            </div>
        </header>

        <div class="status-bar">
            <div class="status-content">
                <div class="status-badges">
                    <span class="badge badge-info" id="presetsStatus">
                        <div class="loading-spinner"></div>
                        Loading presets...
                    </span>
                    <span class="badge" id="configAStatus">Config A: Empty</span>
                    <span class="badge" id="configBStatus">Config B: Empty</span>
                </div>
                <div id="quickStats" class="hidden">
                    Ready to compare â€¢ <span id="totalSettings">0</span> total settings
                </div>
            </div>
        </div>

        <main class="main-content">
            <div class="config-grid">
                <div class="config-card">
                    <div class="config-header">
                        <h2 class="config-title">Configuration A</h2>
                        <span class="config-status status-empty" id="statusA">Empty</span>
                    </div>

                    <div class="input-tabs">
                        <button class="tab-btn active" onclick="switchTab('A', 'text')">CLI Text</button>
                        <button class="tab-btn" onclick="switchTab('A', 'preset')">Preset</button>
                    </div>

                    <div class="tab-content active" id="tabA-text">
                        <div class="form-group">
                            <label class="form-label" for="cliInputA">Paste CLI Export</label>
                            <textarea
                                class="form-control textarea"
                                id="cliInputA"
                                placeholder="# Betaflight / STM32F405 4.4.0
set gyro_lpf1_static_hz = 250
set p_pitch = 58
set i_pitch = 52
..."></textarea>
                        </div>
                        <button class="btn btn-primary" onclick="loadConfigFromText('A')">
                            Load Config A
                        </button>
                    </div>

                    <div class="tab-content" id="tabA-preset">
                        <div class="form-group">
                            <label class="form-label" for="presetSearchA">Search Presets</label>
                            <input type="text" class="form-control" id="presetSearchA" placeholder="Type to search presets...">
                        </div>

                        <div class="form-group">
                            <label class="form-label" for="presetResultsA">Choose Preset</label>
                            <div class="preset-results" id="presetResultsA">
                                <div class="preset-results-placeholder">Loading presets...</div>
                            </div>
                        </div>

                        <div class="preset-options hidden" id="presetOptionsA">
                            <div class="options-header">
                                <span>Preset Options</span>
                                <span class="badge badge-info" id="optionsSummaryA"></span>
                            </div>
                            <div id="optionsListA"></div>
                        </div>
                    </div>

                    <div class="form-group mt-4" id="configInfoA" style="display: none;">
                        <div style="font-size: 13px; color: #6b7280; padding: 8px 12px; background: #f9fafb; border-radius: 6px;">
                            <div id="configDetailsA"></div>
                        </div>
                    </div>
                </div>

                <div class="vs-section">
                    <div class="vs-label">VS</div>
                </div>

                <div class="config-card">
                    <div class="config-header">
                        <h2 class="config-title">Configuration B</h2>
                        <span class="config-status status-empty" id="statusB">Empty</span>
                    </div>

                    <div class="input-tabs">
                        <button class="tab-btn active" onclick="switchTab('B', 'text')">CLI Text</button>
                        <button class="tab-btn" onclick="switchTab('B', 'preset')">Preset</button>
                    </div>

                    <div class="tab-content active" id="tabB-text">
                        <div class="form-group">
                            <label class="form-label" for="cliInputB">Paste CLI Export</label>
                            <textarea
                                class="form-control textarea"
                                id="cliInputB"
                                placeholder="Paste second configuration here..."></textarea>
                        </div>
                        <button class="btn btn-primary" onclick="loadConfigFromText('B')">
                            Load Config B
                        </button>
                    </div>

                    <div class="tab-content" id="tabB-preset">
                        <div class="form-group">
                            <label class="form-label" for="presetSearchB">Search Presets</label>
                            <input type="text" class="form-control" id="presetSearchB" placeholder="Type to search presets...">
                        </div>

                        <div class="form-group">
                            <label class="form-label" for="presetResultsB">Choose Preset</label>
                            <div class="preset-results" id="presetResultsB">
                                <div class="preset-results-placeholder">Loading presets...</div>
                            </div>
                        </div>

                        <div class="preset-options hidden" id="presetOptionsB">
                            <div class="options-header">
                                <span>Preset Options</span>
                                <span class="badge badge-info" id="optionsSummaryB"></span>
                            </div>
                            <div id="optionsListB"></div>
                        </div>
                    </div>

                    <div class="form-group mt-4" id="configInfoB" style="display: none;">
                        <div style="font-size: 13px; color: #6b7280; padding: 8px 12px; background: #f9fafb; border-radius: 6px;">
                            <div id="configDetailsB"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="results-container hidden" id="resultsContainer">
                <div class="results-header">
                    <h2 class="results-title">Comparison Results</h2>
                    <div class="results-nav">
                        <button class="nav-btn active" onclick="showResultsTab('summary')">Summary</button>
                        <button class="nav-btn" onclick="showResultsTab('configs')">Individual</button>
                    </div>
                </div>

                <div class="results-content">
                    <div class="tab-content active" id="results-summary">
                        <div class="comparison-summary">
                            <h3 style="margin: 0 0 8px 0; color: #374151;">Comparison Overview</h3>
                            <div id="comparisonMetadata" style="font-size: 14px; color: #6b7280; margin-bottom: 16px;"></div>
                            <div class="summary-grid">
                                <div class="summary-item">
                                    <span class="summary-number" id="differentCount">0</span>
                                    <span class="summary-label">Different</span>
                                </div>
                                <div class="summary-item">
                                    <span class="summary-number" id="onlyACount">0</span>
                                    <span class="summary-label">Only A</span>
                                </div>
                                <div class="summary-item">
                                    <span class="summary-number" id="onlyBCount">0</span>
                                    <span class="summary-label">Only B</span>
                                </div>
                                <div class="summary-item">
                                    <span class="summary-number" id="sameCount">0</span>
                                    <span class="summary-label">Identical</span>
                                </div>
                            </div>
                        </div>
                        <div id="comparisonDiff"></div>
                    </div>


                    <div class="tab-content" id="results-configs">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px;">
                            <div>
                                <h3 style="color: #374151; margin-bottom: 16px;">Configuration A</h3>
                                <div id="categorizedSettingsA"></div>
                            </div>
                            <div>
                                <h3 style="color: #374151; margin-bottom: 16px;">Configuration B</h3>
                                <div id="categorizedSettingsB"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div style="background: rgba(255, 255, 255, 0.9); border-radius: 8px; padding: 16px; margin-top: 24px; font-size: 14px; color: #64748b; border: 1px solid #e2e8f0;">
                <strong style="color: #374151;">How to use:</strong> Load configurations via CLI text or preset selection, then compare to see differences.
                Presets with [number] have configurable options. Options marked with warning indicators use advanced templating and are not supported.
            </div>
        </main>
    </div>

    <script>
        class BetaflightCLIParser {
            constructor() {
                this.settings = new Map();
                this.categories = this.initializeCategories();
                this.presets = this.initializePresets();
            }

            initializePresets() {
                return {}; // Will be populated dynamically
            }

            async loadPresetsFromGitHub() {
                const startTime = Date.now();
                try {
                    const categories = ['tune']; // Only load TUNE presets
                    const versions = ['4.3', '4.4', '4.5'];
                    const loadedPresets = {};
                    let totalAttempted = 0;
                    let totalLoaded = 0;
                    let totalFiles = 0;
                    let processedFiles = 0;

                    // First pass: count total files to give accurate progress
                    updateProgress(0, 1, 'Scanning preset directories...', 'Counting available presets', startTime);

                    const filesByVersion = {};
                    for (const version of versions) {
                        for (const category of categories) {
                            try {
                                const dirUrl = `https://api.github.com/repos/betaflight/firmware-presets/contents/presets/${version}/${category}`;
                                const response = await fetch(dirUrl);

                                if (response.ok) {
                                    const files = await response.json();
                                    const txtFiles = files.filter(f => f.name.endsWith('.txt'));

                                    if (!filesByVersion[version]) filesByVersion[version] = [];
                                    filesByVersion[version] = filesByVersion[version].concat(txtFiles);
                                    totalFiles += txtFiles.length;

                                    console.log(`Found ${txtFiles.length} .txt files in ${version}/${category}`);
                                }
                            } catch (e) {
                                console.warn(`Failed to scan ${category} presets for ${version}:`, e);
                            }
                        }
                    }

                    updateProgress(1, 1, 'Found preset files', `${totalFiles} preset files discovered`, startTime);

                    // Second pass: actually load the files
                    for (const version of versions) {
                        if (!filesByVersion[version]) continue;

                        const versionFiles = filesByVersion[version];
                        updateProgress(processedFiles, totalFiles, `Loading Betaflight ${version} presets...`, `Processing ${versionFiles.length} files`, startTime);

                        for (let i = 0; i < versionFiles.length; i++) {
                            const file = versionFiles[i];

                            try {
                                // Skip utility files before fetching
                                const utilityFiles = ['blackbox_disable', 'reset_servo', 'defaults_tune_filters', 'defaults_', 'reset_all', 'reset_some', 'reset_'];
                                if (utilityFiles.some(util => file.name.toLowerCase().includes(util))) {
                                    processedFiles++;
                                    continue;
                                }

                                // Update progress with current file
                                updateProgress(
                                    processedFiles,
                                    totalFiles,
                                    `Loading ${version} presets...`,
                                    `Processing: ${file.name} (${processedFiles + 1}/${totalFiles})`,
                                    startTime
                                );

                                const presetResponse = await fetch(file.download_url);
                                if (!presetResponse.ok) {
                                    console.warn(`Failed to fetch ${file.name}: ${presetResponse.status}`);
                                    processedFiles++;
                                    continue;
                                }

                                const presetContent = await presetResponse.text();
                                const parsedPreset = this.parsePresetFile(presetContent, file.name, 'tune', version);

                                if (parsedPreset) {
                                    const key = `${version}_tune_${file.name.replace('.txt', '')}`;
                                    loadedPresets[key] = parsedPreset;
                                    totalLoaded++;
                                    console.log(`âœ“ Loaded: ${parsedPreset.title} (${file.name})`);
                                } else {
                                    console.warn(`Failed to parse ${file.name} - no relevant tune settings found`);
                                }

                                totalAttempted++;
                                processedFiles++;

                                // Small delay to prevent overwhelming the API and allow UI updates
                                if (processedFiles % 5 === 0) {
                                    await new Promise(resolve => setTimeout(resolve, 50));
                                }

                            } catch (e) {
                                console.warn(`Failed to load preset ${file.name}:`, e);
                                processedFiles++;
                            }
                        }
                    }

                    // Final progress update
                    updateProgress(totalFiles, totalFiles, 'Preset loading complete', `Successfully loaded ${totalLoaded} of ${totalAttempted} presets`, startTime);

                    console.log(`Successfully loaded ${totalLoaded} out of ${totalAttempted} attempted tune presets`);
                    this.presets = loadedPresets;

                    // Show completion for a moment before hiding
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    return totalLoaded;
                } catch (error) {
                    console.error('Failed to load presets from GitHub:', error);
                    updateProgress(0, 1, 'Loading failed', 'Using fallback presets instead', startTime);

                    // Fallback to basic presets
                    this.presets = this.getFallbackPresets();

                    await new Promise(resolve => setTimeout(resolve, 1000));
                    return Object.keys(this.presets).length;
                }
            }

            parsePresetFile(content, filename, category, version) {
                try {
                    const lines = content.split('\n');
                    const metadata = {};
                    const settings = {};
                    const options = [];

                    let inOptionBlock = false;
                    let currentOption = null;
                    let inIncludeBlock = false;

                    for (const line of lines) {
                        const trimmed = line.trim();

                        if (trimmed.startsWith('#$ TITLE:')) {
                            metadata.title = trimmed.substring(9).trim();
                        } else if (trimmed.startsWith('#$ DESCRIPTION:')) {
                            const desc = trimmed.substring(15).trim();
                            if (desc && !desc.includes('<') && desc.length < 300) {
                                metadata.description = (metadata.description || '') + desc + ' ';
                            }
                        } else if (trimmed.startsWith('#$ CATEGORY:')) {
                            metadata.category = trimmed.substring(12).trim();
                        } else if (trimmed.startsWith('#$ AUTHOR:')) {
                            metadata.author = trimmed.substring(10).trim();
                        } else if (trimmed.startsWith('#$ STATUS:')) {
                            metadata.status = trimmed.substring(10).trim();
                        }

                        if (trimmed.startsWith('#$ INCLUDE:')) {
                            inIncludeBlock = true;
                            continue;
                        }

                        if (trimmed.startsWith('#$ OPTION BEGIN')) {
                            inOptionBlock = true;
                            const optionMatch = trimmed.match(/^#\$\s*OPTION\s+BEGIN\s*(?:\((CHECKED|UNCHECKED)\))?\s*:\s*(.+)$/);
                            if (optionMatch) {
                                currentOption = {
                                    name: optionMatch[2].trim(),
                                    checked: optionMatch[1] === 'CHECKED',
                                    settings: {}
                                };
                            }
                            continue;
                        } else if (trimmed.startsWith('#$ OPTION END')) {
                            if (currentOption) {
                                options.push(currentOption);
                                currentOption = null;
                            }
                            inOptionBlock = false;
                            continue;
                        }

                        if (trimmed.startsWith('set ')) {
                            const setMatch = trimmed.match(/^set\s+([a-zA-Z0-9_]+)\s*=\s*(.+)$/);
                            if (setMatch) {
                                if (inOptionBlock && currentOption) {
                                    currentOption.settings[setMatch[1]] = setMatch[2].trim();
                                } else {
                                    settings[setMatch[1]] = setMatch[2].trim();
                                }
                            }
                        }
                    }

                    if (!metadata.title) {
                        metadata.title = filename.replace('.txt', '').replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    }

                    const hasRelevantSettings = Object.keys(settings).some(key =>
                        key.includes('_pitch') || key.includes('_roll') || key.includes('_yaw') ||
                        key.includes('dyn_notch') || key.includes('gyro_lpf') ||
                        key.includes('feedforward') || key.includes('dterm') ||
                        key.includes('vbat_sag') || key.includes('thrust_linear')
                    ) || options.length > 0;

                    if ((Object.keys(settings).length > 0 || options.length > 0) && (metadata.title || hasRelevantSettings)) {
                        return {
                            title: metadata.title,
                            description: (metadata.description || '').trim() || `PID tune for Betaflight ${version} (${filename})`,
                            category: metadata.category || 'TUNE',
                            author: metadata.author || 'Unknown',
                            status: metadata.status || 'COMMUNITY',
                            version: version,
                            filename: filename,
                            settings: settings,
                            options: options
                        };
                    }

                    return null;
                } catch (error) {
                    console.warn(`Failed to parse preset file ${filename}:`, error);
                    return null;
                }
            }

            getFallbackPresets() {
                return {
                    'basic_freestyle': {
                        title: 'Basic Freestyle Tune',
                        description: 'Conservative freestyle PID tune that works for most 5" quads',
                        category: 'TUNE',
                        author: 'Fallback',
                        version: '4.3',
                        settings: {
                            'p_pitch': '58', 'i_pitch': '52', 'd_pitch': '52', 'f_pitch': '145',
                            'p_roll': '55', 'i_roll': '50', 'd_roll': '48', 'f_roll': '138',
                            'p_yaw': '55', 'i_yaw': '50', 'd_yaw': '0', 'f_yaw': '138'
                        },
                        options: [
                            {
                                name: 'High Battery Voltage (4.35V)',
                                checked: false,
                                settings: {
                                    'vbat_max_cell_voltage': '435',
                                    'vbat_warning_cell_voltage': '350'
                                }
                            },
                            {
                                name: 'Race Mode Settings',
                                checked: false,
                                settings: {
                                    'p_pitch': '65',
                                    'i_pitch': '65',
                                    'd_pitch': '60'
                                }
                            }
                        ]
                    },
                    'basic_race': {
                        title: 'Basic Race Tune',
                        description: 'Aggressive racing PID tune with higher gains',
                        category: 'TUNE',
                        author: 'Fallback',
                        version: '4.3',
                        settings: {
                            'p_pitch': '70', 'i_pitch': '125', 'd_pitch': '65', 'f_pitch': '270',
                            'p_roll': '65', 'i_roll': '120', 'd_roll': '60', 'f_roll': '250',
                            'p_yaw': '65', 'i_yaw': '120', 'd_yaw': '0', 'f_yaw': '250'
                        },
                        options: []
                    }
                };
            }

            initializeCategories() {
                return {
                    'PID Controller': ['pid_process_denom', 'gyro_lpf1_static_hz', 'gyro_lpf1_dyn_min_hz', 'gyro_lpf1_dyn_max_hz', 'dyn_notch_count', 'dyn_notch_q', 'dyn_notch_min_hz', 'dyn_notch_max_hz'],
                    'PID Tuning': ['p_pitch', 'i_pitch', 'd_pitch', 'p_roll', 'i_roll', 'd_roll', 'p_yaw', 'i_yaw', 'd_yaw', 'f_pitch', 'f_roll', 'f_yaw'],
                    'RC Rates': ['rc_smoothing_type', 'rc_smoothing_input_hz', 'rc_smoothing_derivative_hz', 'serialrx_provider', 'sbus_inversion'],
                    'Rates': ['roll_rc_rate', 'pitch_rc_rate', 'yaw_rc_rate', 'roll_expo', 'pitch_expo', 'yaw_expo', 'roll_srate', 'pitch_srate', 'yaw_srate'],
                    'Motors': ['motor_pwm_protocol', 'motor_pwm_rate', 'motor_poles', 'thrust_linear'],
                    'Battery & Power': ['bat_capacity', 'vbat_max_cell_voltage', 'vbat_min_cell_voltage', 'vbat_warning_cell_voltage', 'ibata_scale', 'ibata_offset'],
                    'OSD': ['osd_vbat_pos', 'osd_rssi_pos', 'osd_tim_1_pos', 'osd_tim_2_pos', 'osd_remaining_time_estimate_pos', 'osd_flymode_pos'],
                    'Failsafe': ['failsafe_delay', 'failsafe_off_delay', 'failsafe_throttle', 'failsafe_switch_mode', 'failsafe_throttle_low_delay'],
                    'GPS': ['gps_provider', 'gps_sbas_mode', 'gps_auto_config', 'gps_auto_baud', 'gps_ublox_use_galileo'],
                    'Blackbox': ['blackbox_device', 'blackbox_record_acc', 'blackbox_mode'],
                    'System': ['gyro_hardware_lpf', 'gyro_32khz_hardware_lpf', 'gyro_sync_denom', 'scheduler_optimize_rate'],
                    'Other': []
                };
            }

            parse(cliText) {
                this.settings.clear();
                const lines = cliText.split('\n');
                let parsedCount = 0;

                for (const line of lines) {
                    const trimmed = line.trim();

                    if (!trimmed || trimmed.startsWith('#')) {
                        continue;
                    }

                    if (trimmed.startsWith('set ')) {
                        const result = this.parseSetCommand(trimmed);
                        if (result) {
                            this.settings.set(result.parameter, result.value);
                            parsedCount++;
                        }
                    }
                }

                return {
                    success: true,
                    settingsCount: parsedCount,
                    totalLines: lines.length,
                    settings: this.settings
                };
            }

            parseSetCommand(line) {
                const match = line.match(/^set\s+([a-zA-Z0-9_]+)\s*=\s*(.+)$/);
                if (match) {
                    return {
                        parameter: match[1].trim(),
                        value: match[2].trim()
                    };
                }
                return null;
            }

            categorizeSettings() {
                const categorized = {};
                const foundSettings = new Set();

                for (const [categoryName, parameters] of Object.entries(this.categories)) {
                    categorized[categoryName] = [];
                }

                for (const [categoryName, parameters] of Object.entries(this.categories)) {
                    if (categoryName === 'Other') continue;

                    for (const param of parameters) {
                        if (this.settings.has(param)) {
                            categorized[categoryName].push({
                                parameter: param,
                                value: this.settings.get(param)
                            });
                            foundSettings.add(param);
                        }
                    }
                }

                for (const [param, value] of this.settings) {
                    if (!foundSettings.has(param)) {
                        categorized['Other'].push({
                            parameter: param,
                            value: value
                        });
                    }
                }

                for (const categoryName of Object.keys(categorized)) {
                    if (categorized[categoryName].length === 0) {
                        delete categorized[categoryName];
                    }
                }

                return categorized;
            }
        }

        const parser = new BetaflightCLIParser();
        let presetsLoaded = false;
        let configA = null;
        let configB = null;
        let currentResultsTab = 'summary';
        let allPresetsA = []; // Store all preset options for filtering
        let allPresetsB = []; // Store all preset options for filtering

        // Initialize app
        window.addEventListener('DOMContentLoaded', function() {
            loadPresets();
            updateUI();
            setupSearchListeners();
            setupPresetResultsListeners();
        });

        function setupSearchListeners() {
            const searchA = document.getElementById('presetSearchA');
            const searchB = document.getElementById('presetSearchB');

            searchA.addEventListener('input', function() {
                filterPresets('A', this.value);
            });

            searchB.addEventListener('input', function() {
                filterPresets('B', this.value);
            });
        }

        function filterPresets(side, searchTerm) {
            const resultsContainer = document.getElementById(`presetResults${side}`);
            const allPresets = side === 'A' ? allPresetsA : allPresetsB;

            // Clear current selection visual if user is searching
            const currentlySelected = resultsContainer.querySelector('.preset-item.selected');
            if(currentlySelected) {
                currentlySelected.classList.remove('selected');
            }
            if (side === 'A') { configA = null; } else { configB = null; }
            hidePresetOptions(side);
            updateUI();


            if (!searchTerm.trim()) {
                populatePresetResults(resultsContainer, allPresets);
                return;
            }

            const searchLower = searchTerm.toLowerCase();
            const filtered = allPresets.filter(preset => {
                const title = preset.preset.title.toLowerCase();
                const author = (preset.preset.author || '').toLowerCase();
                const description = (preset.preset.description || '').toLowerCase();

                return title.includes(searchLower) ||
                    author.includes(searchLower) ||
                    description.includes(searchLower);
            });

            populatePresetResults(resultsContainer, filtered);
        }

        function populatePresetResults(resultsContainer, presets) {
            resultsContainer.innerHTML = '';

            if (presets.length === 0) {
                resultsContainer.innerHTML = '<div class="preset-results-placeholder">No matching presets found.</div>';
                return;
            }

            const grouped = {};

            // Group presets by version
            for (const preset of presets) {
                const groupKey = `Betaflight ${preset.preset.version}`;
                if (!grouped[groupKey]) {
                    grouped[groupKey] = [];
                }
                grouped[groupKey].push(preset);
            }

            // Sort within each group
            for (const groupKey in grouped) {
                grouped[groupKey].sort((a, b) => a.preset.title.localeCompare(b.preset.title));
            }

            // Add options to results container
            for (const [groupName, groupPresets] of Object.entries(grouped)) {
                if (groupPresets.length > 0) {
                    const groupDiv = document.createElement('div');
                    groupDiv.className = 'preset-group';
                    groupDiv.textContent = groupName;
                    resultsContainer.appendChild(groupDiv);

                    for (const { key, preset } of groupPresets) {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'preset-item';
                        itemDiv.dataset.presetKey = key;

                        const optionsIndicator = preset.options && preset.options.length > 0 ? ` [${preset.options.length}]` : '';
                        const authorHtml = preset.author ? `<span class="preset-item-author">by ${preset.author}</span>` : '';

                        itemDiv.innerHTML = `
                            <span class="preset-item-title">${preset.title}${optionsIndicator}</span>
                            ${authorHtml}
                        `;
                        resultsContainer.appendChild(itemDiv);
                    }
                }
            }
        }

        async function loadPresets() {
            const presetsStatus = document.getElementById('presetsStatus');

            try {
                showLoadingProgress();
                const count = await parser.loadPresetsFromGitHub();
                initializePresetSelection();

                hideLoadingProgress();
                presetsStatus.className = 'badge badge-success';
                presetsStatus.innerHTML = `${count} presets loaded`;
                presetsLoaded = true;

            } catch (error) {
                console.error('Failed to load presets:', error);
                hideLoadingProgress();
                presetsStatus.className = 'badge badge-warning';
                presetsStatus.innerHTML = 'Using fallback presets';
                initializePresetSelection();
            }
        }

        function showLoadingProgress() {
            const mainContent = document.querySelector('.main-content');
            const progressHtml = `
                <div class="progress-container" id="progressContainer">
                    <div class="progress-header">
                        <div class="progress-title">
                            <div class="loading-spinner"></div>
                            <span id="progressTitle">Initializing...</span>
                        </div>
                        <div class="progress-stats" id="progressStats">0%</div>
                    </div>
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="progressBar" style="width: 0%"></div>
                    </div>
                    <div class="progress-details">
                        <span id="progressDetails">Starting up...</span>
                        <span class="progress-eta" id="progressETA"></span>
                    </div>
                </div>
            `;
            mainContent.insertAdjacentHTML('afterbegin', progressHtml);
        }

        function updateProgress(current, total, title, details, startTime = null) {
            const progressBar = document.getElementById('progressBar');
            if (!progressBar) return;
            const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
            progressBar.style.width = `${percentage}%`;
            document.getElementById('progressStats').textContent = `${percentage}%`;
            document.getElementById('progressTitle').textContent = title;
            document.getElementById('progressDetails').textContent = details;
        }

        function hideLoadingProgress() {
            const progressContainer = document.getElementById('progressContainer');
            if (progressContainer) progressContainer.remove();
        }

        function initializePresetSelection() {
            const resultsA = document.getElementById('presetResultsA');
            const resultsB = document.getElementById('presetResultsB');

            allPresetsA = [];
            allPresetsB = [];

            for (const [key, preset] of Object.entries(parser.presets)) {
                allPresetsA.push({ key, preset });
                allPresetsB.push({ key, preset });
            }

            populatePresetResults(resultsA, allPresetsA);
            populatePresetResults(resultsB, allPresetsB);
        }

        function setupPresetResultsListeners() {
            const resultsA = document.getElementById('presetResultsA');
            const resultsB = document.getElementById('presetResultsB');

            [resultsA, resultsB].forEach(container => {
                const side = container.id.includes('A') ? 'A' : 'B';
                container.addEventListener('click', function(event) {
                    const target = event.target.closest('.preset-item');
                    if (target && target.dataset.presetKey) {
                        const presetKey = target.dataset.presetKey;

                        const previouslySelected = container.querySelector('.preset-item.selected');
                        if (previouslySelected) {
                            previouslySelected.classList.remove('selected');
                        }
                        target.classList.add('selected');

                        showPresetOptions(side, presetKey);
                    }
                });
            });
        }

        function showPresetOptions(side, presetKey) {
            const preset = parser.presets[presetKey];
            const optionsDiv = document.getElementById(`presetOptions${side}`);
            const optionsListDiv = document.getElementById(`optionsList${side}`);
            const summaryBadge = document.getElementById(`optionsSummary${side}`);

            if (!preset || !preset.options || preset.options.length === 0) {
                hidePresetOptions(side);
                loadConfigFromPreset(side, presetKey); // Load directly if no options
                return;
            }

            let html = '';
            let supportedCount = 0;
            let unsupportedCount = 0;

            preset.options.forEach((option, index) => {
                const optionId = `option_${side}_${index}`;
                const hasSettings = option.settings && Object.keys(option.settings).length > 0;

                if (hasSettings) {
                    supportedCount++;
                    const settingsPreview = Object.entries(option.settings).slice(0, 2).map(([key, value]) =>
                        `${key} = ${value}`
                    ).join(', ');
                    const moreSettings = Object.keys(option.settings).length > 2 ? ` (+${Object.keys(option.settings).length - 2} more)` : '';

                    html += `
                        <div class="option-item">
                            <div class="option-label-wrapper">
                                <input type="checkbox" class="option-checkbox" id="${optionId}" ${option.checked ? 'checked' : ''}
                                       onchange="onOptionChanged('${side}', '${presetKey}')">
                                <label class="option-label" for="${optionId}">${option.name}</label>
                            </div>
                            <div class="option-settings">${settingsPreview}${moreSettings}</div>
                        </div>
                    `;
                } else {
                    unsupportedCount++;
                    html += `
                        <div class="option-item disabled">
                            <div class="option-label-wrapper">
                                <input type="checkbox" class="option-checkbox" id="${optionId}" disabled>
                                <label class="option-label disabled" for="${optionId}">${option.name}</label>
                            </div>
                            <div class="option-unsupported">Uses advanced templating (unsupported)</div>
                        </div>
                    `;
                }
            });

            optionsListDiv.innerHTML = html;
            summaryBadge.textContent = `${supportedCount} supported, ${unsupportedCount} unsupported`;
            optionsDiv.classList.remove('hidden');

            loadConfigFromPreset(side, presetKey);
        }

        function hidePresetOptions(side) {
            document.getElementById(`presetOptions${side}`).classList.add('hidden');
        }

        function onOptionChanged(side, presetKey) {
            loadConfigFromPreset(side, presetKey);
        }

        function switchTab(side, tab) {
            const activeCard = document.querySelector(`#tab${side}-${tab}`).closest('.config-card');
            const buttons = activeCard.querySelectorAll('.tab-btn');
            buttons.forEach((btn, index) => {
                btn.classList.toggle('active', index === (tab === 'text' ? 0 : 1));
            });

            document.getElementById(`tab${side}-text`).classList.toggle('active', tab === 'text');
            document.getElementById(`tab${side}-preset`).classList.toggle('active', tab === 'preset');
        }

        function loadConfigFromText(side) {
            const textArea = document.getElementById(`cliInput${side}`);
            if (!textArea.value.trim()) {
                alert(`Please paste CLI export data for Configuration ${side}!`);
                return;
            }

            setLoadingState(side, true);
            setTimeout(() => {
                const tempParser = new BetaflightCLIParser();
                const result = tempParser.parse(textArea.value);
                const config = {
                    type: 'text',
                    title: `Custom CLI Export ${side}`,
                    settings: new Map(tempParser.settings),
                    metadata: { settingsCount: result.settingsCount }
                };
                if (side === 'A') configA = config; else configB = config;
                setLoadingState(side, false);
                updateUI();
            }, 200);
        }

        function loadConfigFromPreset(side, presetKey) {
            if (!presetKey) return;
            setLoadingState(side, true);

            setTimeout(() => {
                const preset = parser.presets[presetKey];
                if (!preset) {
                    setLoadingState(side, false); return;
                }

                const finalSettings = new Map(Object.entries(preset.settings));
                const appliedOptions = [];

                if (preset.options && preset.options.length > 0) {
                    preset.options.forEach((option, index) => {
                        const optionCheckbox = document.getElementById(`option_${side}_${index}`);
                        if (optionCheckbox && optionCheckbox.checked && !optionCheckbox.disabled) {
                            for (const [key, value] of Object.entries(option.settings)) {
                                finalSettings.set(key, value);
                            }
                            appliedOptions.push(option.name);
                        }
                    });
                }

                const config = {
                    type: 'preset',
                    title: preset.title,
                    description: preset.description,
                    settings: finalSettings,
                    metadata: { ...preset, optionsApplied: appliedOptions }
                };
                if (side === 'A') configA = config; else configB = config;
                setLoadingState(side, false);
                updateUI();
            }, 150);
        }

        function updateUI() {
            // Config A
            const statusA = document.getElementById('statusA');
            const configAStatus = document.getElementById('configAStatus');
            const cardA = document.querySelector('.config-card:first-of-type');
            if (configA) {
                statusA.textContent = 'Loaded'; statusA.className = 'config-status status-loaded';
                configAStatus.textContent = `Config A: ${configA.title}`; configAStatus.className = 'badge badge-success';
                cardA.setAttribute('data-loaded', 'true'); cardA.removeAttribute('data-loading');
                const detailsA = document.getElementById('configDetailsA');
                const infoA = document.getElementById('configInfoA');
                detailsA.innerHTML = `<strong>${configA.title}</strong><br>${configA.settings.size} settings loaded ${configA.metadata?.optionsApplied?.length ? `<br>Options: ${configA.metadata.optionsApplied.join(', ')}` : ''}`;
                infoA.style.display = 'block';
            } else {
                statusA.textContent = 'Empty'; statusA.className = 'config-status status-empty';
                configAStatus.textContent = 'Config A: Empty'; configAStatus.className = 'badge';
                cardA.removeAttribute('data-loaded'); cardA.removeAttribute('data-loading');
                document.getElementById('configInfoA').style.display = 'none';
            }

            // Config B
            const statusB = document.getElementById('statusB');
            const configBStatus = document.getElementById('configBStatus');
            const cardB = document.querySelector('.config-card:last-of-type');
            if (configB) {
                statusB.textContent = 'Loaded'; statusB.className = 'config-status status-loaded';
                configBStatus.textContent = `Config B: ${configB.title}`; configBStatus.className = 'badge badge-success';
                cardB.setAttribute('data-loaded', 'true'); cardB.removeAttribute('data-loading');
                const detailsB = document.getElementById('configDetailsB');
                const infoB = document.getElementById('configInfoB');
                detailsB.innerHTML = `<strong>${configB.title}</strong><br>${configB.settings.size} settings loaded ${configB.metadata?.optionsApplied?.length ? `<br>Options: ${configB.metadata.optionsApplied.join(', ')}` : ''}`;
                infoB.style.display = 'block';
            } else {
                statusB.textContent = 'Empty'; statusB.className = 'config-status status-empty';
                configBStatus.textContent = 'Config B: Empty'; configBStatus.className = 'badge';
                cardB.removeAttribute('data-loaded'); cardB.removeAttribute('data-loading');
                document.getElementById('configInfoB').style.display = 'none';
            }

            // Buttons and Stats
            const canCompare = configA && configB;
            document.getElementById('compareBtn').disabled = !canCompare;
            const quickStats = document.getElementById('quickStats');
            if (canCompare) {
                document.getElementById('totalSettings').textContent = new Set([...configA.settings.keys(), ...configB.settings.keys()]).size;
                quickStats.classList.remove('hidden');
            } else {
                quickStats.classList.add('hidden');
            }
        }

        function setLoadingState(side, isLoading) {
            const card = side === 'A' ? document.querySelector('.config-card:first-of-type') : document.querySelector('.config-card:last-of-type');
            const status = document.getElementById(`status${side}`);
            const badge = document.getElementById(`config${side}Status`);
            if (isLoading) {
                card.setAttribute('data-loading', 'true'); card.removeAttribute('data-loaded');
                status.textContent = 'Loading...'; status.className = 'config-status status-loading';
                badge.textContent = `Config ${side}: Loading...`; badge.className = 'badge badge-info';
            } else {
                card.removeAttribute('data-loading');
            }
        }

        function compareConfigs() {
            if (!configA || !configB) return;
            const comparison = compareConfigurations(configA, configB);
            displayComparison(comparison);
            document.getElementById('resultsContainer').classList.remove('hidden');
            document.getElementById('resultsContainer').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function compareConfigurations(configA, configB) {
            const changes = [];
            const allParams = new Set([...configA.settings.keys(), ...configB.settings.keys()]);
            for (const param of allParams) {
                const valueA = configA.settings.get(param);
                const valueB = configB.settings.get(param);
                if (valueA === undefined) changes.push({ parameter: param, type: 'only_b', valueA: null, valueB: valueB });
                else if (valueB === undefined) changes.push({ parameter: param, type: 'only_a', valueA: valueA, valueB: null });
                else if (valueA !== valueB) changes.push({ parameter: param, type: 'different', valueA: valueA, valueB: valueB });
                else changes.push({ parameter: param, type: 'same', valueA: valueA, valueB: valueB });
            }
            return { configA, configB, changes };
        }

        function displayComparison(comparison) {
            const different = comparison.changes.filter(c => c.type === 'different');
            const onlyA = comparison.changes.filter(c => c.type === 'only_a');
            const onlyB = comparison.changes.filter(c => c.type === 'only_b');
            const same = comparison.changes.filter(c => c.type === 'same');

            document.getElementById('differentCount').textContent = different.length;
            document.getElementById('onlyACount').textContent = onlyA.length;
            document.getElementById('onlyBCount').textContent = onlyB.length;
            document.getElementById('sameCount').textContent = same.length;
            document.getElementById('comparisonMetadata').innerHTML = `<strong>A:</strong> ${comparison.configA.title} â€¢ <strong>B:</strong> ${comparison.configB.title}`;

            let diffHtml = '';
            if (different.length > 0) {
                diffHtml += '<div class="diff-section"><div class="diff-header">Different Values</div>';
                different.sort((a,b) => a.parameter.localeCompare(b.parameter)).forEach(c => {
                    diffHtml += `<div class="diff-item diff-changed"><span class="setting-name">${c.parameter}</span><div class="setting-values"><span class="value-a">A: ${c.valueA}</span> â†’ <span class="value-b">B: ${c.valueB}</span></div></div>`;
                });
                diffHtml += '</div>';
            }
            if (onlyA.length > 0) {
                diffHtml += '<div class="diff-section"><div class="diff-header">Only in Configuration A</div>';
                onlyA.sort((a,b) => a.parameter.localeCompare(b.parameter)).forEach(c => {
                    diffHtml += `<div class="diff-item diff-only-a"><span class="setting-name">${c.parameter}</span><span class="value-a">${c.valueA}</span></div>`;
                });
                diffHtml += '</div>';
            }
            if (onlyB.length > 0) {
                diffHtml += '<div class="diff-section"><div class="diff-header">Only in Configuration B</div>';
                onlyB.sort((a,b) => a.parameter.localeCompare(b.parameter)).forEach(c => {
                    diffHtml += `<div class="diff-item diff-only-b"><span class="setting-name">${c.parameter}</span><span class="value-b">${c.valueB}</span></div>`;
                });
                diffHtml += '</div>';
            }
            if (different.length === 0 && onlyA.length === 0 && onlyB.length === 0) {
                diffHtml = '<div class="text-center" style="padding: 40px; color: #16a34a; font-weight: 500;">Configurations are identical!</div>';
            }
            document.getElementById('comparisonDiff').innerHTML = diffHtml;
            generateIndividualConfigs(comparison);
        }

        function generateIndividualConfigs(comparison) {
            const categorizedA = categorizeSettings(comparison.configA.settings);
            const categorizedB = categorizeSettings(comparison.configB.settings);
            document.getElementById('categorizedSettingsA').innerHTML = renderCategorizedSettings(categorizedA);
            document.getElementById('categorizedSettingsB').innerHTML = renderCategorizedSettings(categorizedB);
        }

        function categorizeSettings(settings) {
            const categories = parser.categories;
            const categorized = {};
            const foundSettings = new Set();
            for (const categoryName of Object.keys(categories)) { categorized[categoryName] = []; }

            for (const [param, value] of settings) {
                let found = false;
                for (const [categoryName, parameters] of Object.entries(categories)) {
                    if (parameters.includes(param)) {
                        categorized[categoryName].push({ parameter: param, value: value });
                        found = true;
                        break;
                    }
                }
                if (!found) categorized['Other'].push({ parameter: param, value: value });
            }
            return Object.fromEntries(Object.entries(categorized).filter(([_, v]) => v.length > 0));
        }

        function renderCategorizedSettings(categorized) {
            let html = '';
            for (const [categoryName, settings] of Object.entries(categorized)) {
                html += `<div style="margin-bottom: 20px;"><h4 style="color: #374151; font-size: 14px; font-weight: 600; margin-bottom: 8px; padding-bottom: 4px; border-bottom: 1px solid #e5e7eb;">${categoryName} (${settings.length})</h4><div style="font-size: 12px; font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;">`;
                settings.forEach(s => {
                    html += `<div style="display: flex; justify-content: space-between; padding: 2px 0; color: #6b7280;"><span style="color: #374151; font-weight: 500;">${s.parameter}</span><span>${s.value}</span></div>`;
                });
                html += '</div></div>';
            }
            return html;
        }

        function showResultsTab(tab) {
            currentResultsTab = tab;
            document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            document.querySelectorAll('#resultsContainer .tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`results-${tab}`).classList.add('active');
        }

        function clearAll() {
            configA = null; configB = null;
            document.getElementById('cliInputA').value = '';
            document.getElementById('cliInputB').value = '';
            document.getElementById('presetSearchA').value = '';
            document.getElementById('presetSearchB').value = '';

            filterPresets('A', '');
            filterPresets('B', '');

            hidePresetOptions('A');
            hidePresetOptions('B');
            document.getElementById('resultsContainer').classList.add('hidden');
            updateUI();
        }

        document.getElementById('compareBtn').addEventListener('click', compareConfigs);
        document.getElementById('clearBtn').addEventListener('click', clearAll);
    </script>
</body>
</html>
